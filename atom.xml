<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff&#39;s WebTech Note</title>
  
  <subtitle>Life &amp; technology note</subtitle>
  <link href="https://blog.crazyalu.com/atom.xml" rel="self"/>
  
  <link href="https://blog.crazyalu.com/"/>
  <updated>2024-02-21T14:30:20.006Z</updated>
  <id>https://blog.crazyalu.com/</id>
  
  <author>
    <name>Jeff Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Day 30：使用 Parchment 實現類似 Medium 的編輯器 - Videos &amp; Tweets</title>
    <link href="https://blog.crazyalu.com/2023/10/15/quill-day-30/"/>
    <id>https://blog.crazyalu.com/2023/10/15/quill-day-30/</id>
    <published>2023-10-15T15:05:24.000Z</published>
    <updated>2024-02-21T14:30:20.006Z</updated>
    
    <content type="html"><![CDATA[<p>今天來到了挑戰的最後一天，接著把剩下的 Videos 和 Tweets 等自訂 Blot 體驗一遍。</p><h2 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h2><p>我們將以和 images 的實現方式來實現 Videos。從第一個直覺或許可以使用 HTML 的 <code>&lt;video&gt;</code> 標籤，但我們無法用這種方式來播放 Youtube 的影片，考慮到 Youtube 影片是目前主流看影片的其中一種方式，我們就用 <code>&lt;iframe&gt;</code> 標籤來實現。如果希望多個 Blot 使用相同的標籤，除了 <code>tagName</code> 之外，我們還可以使用 <code>className</code>，下一個 Tweets 練習會示範這個部分。</p><p>另外，我們將支援對寬度與高度，作為未註冊的 Formats。特定於 Embeds 的 Formats 不需要單獨註冊，只要它們與已註冊的 Formats 沒有命名空間的衝突即可。這樣可以運作是因為 Blots 只是將未知的 Foramts 傳遞給其子元素，最終達到葉節點。這也允許不同的 Embeds 以不同的方式處理未註冊的 Formats。例如，我們之前的插入圖片可能會跟我們在這裡的 Videos 以不同的方式來識別和處理寬度格式。</p><pre><code class="typescript">export class VideoBlot extends BlockEmbed &#123;  static blotName = &#39;myVideo&#39;;  static tagName = &#39;iframe&#39;;  static create(value: &#123; url: string &#125;) &#123;    const node = super.create();    node.setAttribute(&#39;src&#39;, value.url);    // Set non-format related attributes with static values    node.setAttribute(&#39;frameborder&#39;, &#39;0&#39;);    node.setAttribute(&#39;allowfullscreen&#39;, &#39;true&#39;);    return node;  &#125;  static formats(node: HTMLIFrameElement): Format &#123;    let format: Format = &#123;&#125;;    if (node.hasAttribute(&#39;height&#39;)) &#123;      format[&#39;height&#39;] = node.getAttribute(&#39;height&#39;)!;    &#125;    if (node.hasAttribute(&#39;width&#39;)) &#123;      format[&#39;width&#39;] = node.getAttribute(&#39;width&#39;)!;    &#125;    return format;  &#125;  static value(node: HTMLImageElement) &#123;    return node.getAttribute(&#39;src&#39;);  &#125;  format(name: string, value: number | string) &#123;    // Handle unregistered embed formats    if (name === &#39;height&#39; || name === &#39;width&#39;) &#123;      if (value) &#123;        this[&#39;domNode&#39;].setAttribute(name, value);      &#125; else &#123;        this[&#39;domNode&#39;] .removeAttribute(name, value);      &#125;    &#125; else &#123;      super.format(name, value);    &#125;  &#125;&#125;</code></pre><p>新增 VideoBlot 之後，和前面幾次練習一樣，註冊到 Quill，並且加上對應的 Click Event 到 Component：</p><pre><code class="html">  &lt;button type=&quot;button&quot; title=&quot;video&quot; id=&quot;video-button&quot; (click)=&quot;addVideo()&quot;&gt;    &lt;i class=&quot;fa fa-play&quot;&gt;&lt;/i&gt;  &lt;/button&gt;</code></pre><pre><code class="typescript">  registerBasicFormatting() &#123;    // ...    Quill.register(VideoBlot);  &#125;  addVideo() &#123;    const range = this.quillInstance.getSelection(true);    this.quillInstance.insertText(range.index, &#39;\n&#39;, Quill.sources.USER);    this.quillInstance.insertEmbed(range.index + 1, &#39;myVideo&#39;, &#123;      url: &#39;https://www.youtube.com/embed/QHH3iSeDBLo&#39;,    &#125;);    this.quillInstance.formatText(range.index + 1, 1, &#123;      height: &#39;170&#39;,      width: &#39;400&#39;,    &#125;);    this.quillInstance.setSelection(      &#123; index: range.index + 2, length: 0 &#125;,      Quill.sources.SILENT    );  &#125;</code></pre><p>點擊按鈕嵌入 Youtube 影片之後，可以看到編輯器的內容加了一個 <code>iframe</code> 標籤：</p><p><img src="/2023/10/15/quill-day-30/20090749bmGrHQyGj4.png" alt="編輯器的內容加了一個 `iframe` 標籤"></p><p>如果打開 dev tool 使用 <code>getContents</code> 方法來查看編輯器內容，Quill 會回傳 Video 的 Delta 內容像這樣：</p><pre><code class="json">&#123;  ops: [&#123;    insert: &#123;      video: &#39;https://www.youtube.com/embed/QHH3iSeDBLo?showinfo=0&#39;    &#125;,    attributes: &#123;      height: &#39;170&#39;,      width: &#39;400&#39;    &#125;  &#125;]&#125;</code></pre><h2 id="Tweets"><a href="#Tweets" class="headerlink" title="Tweets"></a>Tweets</h2><p>Medium 支援多種嵌入類型，但我們練習就只專注於 Tweets。Tweet Blot 的實現方式與 images 幾乎完全相同。我們利用 Embed Blots 不一定要對應到一個空（void）節點的行為。它可以是任何自定義的節點，Quill 會將其視為一個空節點，而不遍歷其子節點或後代節點。這使我們可以使用一個 <code>&lt;div&gt;</code>，並讓原生的 Twitter Javascript 函式庫在我們指定的 <code>&lt;div&gt;</code> 容器內運作。</p><p>由於我們的根 Scroll Blot 也使用了一個 <code>&lt;div&gt;</code>，所以我們還指定了一個 className 來消除歧義。需要注意的是，Inline Blots 預設使用 <code>&lt;span&gt;</code>，而 Block Blots 預設使用 <code>&lt;p&gt;</code>。因此，如果想讓自定義的 Blots 使用這些標籤，除了指定 <code>tagName</code> 之外，還要帶上一個 <code>className</code>。</p><p>我們使用 Tweet id 作為定義我們 Blot 的值。同樣的，在 Click Event handler 一樣帶入固定值來方便練習。</p><pre><code class="typescript">export class TweetBlot extends BlockEmbed &#123;  static blotName = &#39;myTweet&#39;;  static tagName = &#39;div&#39;;  static className = &#39;tweet&#39;;  static create(id: string) &#123;    const node = super.create();    node.dataset.id = id;    // Allow twitter library to modify our content    twttr.widgets.createTweet(id, node);    return node;  &#125;  static value(domNode: HTMLElement) &#123;    return domNode.dataset[&#39;id&#39;];  &#125;&#125;</code></pre><p>上面這個範例程式中，如果直接加上 <code>twttr</code> 應該會出現 TypeScript 不認得的錯誤訊息，<code>twttr</code> 是 Twitter platform widgets.js 函式庫提供的，因此我們這邊就先使用 <code>declare</code> any 來定義它的型別：</p><pre><code class="typescript">declare var twttr: any;</code></pre><p>此外，我們還需要加上 Twitter widgets 的 JS script，這邊我們可以利用 Angular 提供的 <code>Renderer2</code> 來插入外部的 <code>script</code>，當然也可以直接在 <code>index.html</code> 的檔案上加入：</p><pre><code class="typescript">import &#123; CommonModule, DOCUMENT &#125; from &#39;@angular/common&#39;;import &#123;  AfterViewInit,  Component,  ElementRef,  Inject,  OnInit,  Renderer2,  SecurityContext,  ViewChild,&#125; from &#39;@angular/core&#39;;// ...Component  constructor(    // ...    private renderer: Renderer2,    @Inject(DOCUMENT) private document: Document  ) &#123;&#125;  ngOnInit(): void &#123;    const script = this.renderer.createElement(&#39;script&#39;);    script.type = &#39;text/javascript&#39;;    script.src = &#39;https://platform.twitter.com/widgets.js&#39;;    script.async = true;    script.charset = &#39;utf-8&#39;;    this.renderer.appendChild(this.document.body, script);  &#125;</code></pre><p>建立好 TweetBlot 之後，我們一樣進行 Quill 註冊以及綁定 click event 對應的按鈕：</p><pre><code class="html">  &lt;button type=&quot;button&quot; title=&quot;tweet&quot; id=&quot;tweet-button&quot; (click)=&quot;addTweet()&quot;&gt;    &lt;i class=&quot;fa-brands fa-twitter&quot;&gt;&lt;/i&gt;  &lt;/button&gt;</code></pre><p>使用 Quill Instance 提供的方法取得游標位置，並插入 TweetBlot 的區塊：</p><pre><code class="typescript">  registerBasicFormatting() &#123;    // ...    Quill.register(TweetBlot);  &#125;  addTweet() &#123;    const range = this.quillInstance.getSelection(true);    const id = &#39;464454167226904576&#39;;    this.quillInstance.insertText(range.index, &#39;\n&#39;, Quill.sources.USER);    this.quillInstance.insertEmbed(      range.index + 1,      &#39;myTweet&#39;,      id,      Quill.sources.USER    );    this.quillInstance.setSelection(      &#123; index: range.index + 2, length: 0 &#125;,      Quill.sources.SILENT    );  &#125;</code></pre><p>點擊後的效果：</p><p><img src="/2023/10/15/quill-day-30/20090749OJWSQiyGaN.png" alt="點擊後的效果"></p><h2 id="最後的潤色"><a href="#最後的潤色" class="headerlink" title="最後的潤色"></a>最後的潤色</h2><p>我們從一堆按鈕和只能理解純文本的 Quill 核心開始。通過 Parchment，我們能夠添加粗體、斜體、連結、引用區塊、標題、分隔線、圖片、影片，甚至是 Tweets。所有這些都能在維持一個可預測且一致性的文件實現，這使我們能夠使用 Quill 的 API 來處理這些新的格式和內容。</p><p>讓我們為這個範例加上一些最後的潤色。雖然它不能與 Medium 的 UI 相比，但還是盡可能的去貼近它。</p><p>最後的效果，當選擇文本時會顯示工具列：</p><p><img src="/2023/10/15/quill-day-30/20090749aoYxsaa9cE.png" alt="顯示工具列"></p><p>游標換行之後停在最前面的時候顯示插入內容按鈕，點擊之後可以展開內容：</p><p><img src="/2023/10/15/quill-day-30/200907499NssOAmiEm.png" alt="點擊之後可以展開內容"></p><p>具體的程式碼變更可以參考對應的 commit 紀錄。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>終於來到了第 30 天，最後用了這個練習把 Quill 的東西初步都摸過了一遍。今天把剩下的練習像是 Video, Tweets 這些自訂的 Blot 插入，並把整個 UI 改成像是 Medium 的編輯器風格。從中學到不少東西，也因為很久沒碰 Angular，有一些對我來說可能是新的東西也派上用場，目前的實現並不是最好的實現方式，因為官方提供的範例是直接用 jQuery，那我想在 Angular 專案的話，應該要透過 Angular 的生態系統下來實現正確的 UI 操作方式，這個未來可以在持續的探討。同時有機會的話也可以改成 Signal 的版本 XD</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天下午繼續參加週末的 MNH 社群日，遇到很多低等的會想挑戰高階的魔物，想挑戰的心態值得嘉許，但更多的可能是想蹭並獲取材料，對於等級可能剛剛好可以應付魔物的玩家，如果遇到這樣的情況就會很尷尬，因為不一定能夠扛著住，所以現在加入一個組隊之後，都要先觀望一下隊友的等級，才知道這場會不會又整個翻車，畢竟藥水真的不便宜 QQ</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/87471dd20edfb511016b37facb434a65c25499f6">今日份的練習：加入 Videos, Tweets</a></li><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/4bc1769ecf17e035cd0a56d4555fb1f03e81ea6d">今日份的練習：改成 Medium like UI</a></li><li><a href="https://quilljs.com/guides/cloning-medium-with-parchment/#videos">Cloning Medium with Parchment - Quill (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10340029">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天來到了挑戰的最後一天，接著把剩下的 Videos 和 Tweets 等自訂 Blot 體驗一遍。&lt;/p&gt;
&lt;h2 id=&quot;Videos&quot;&gt;&lt;a href=&quot;#Videos&quot; class=&quot;headerlink&quot; title=&quot;Videos&quot;&gt;&lt;/a&gt;Videos&lt;/h2</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 29：使用 Parchment 實現類似 Medium 的編輯器 - Dividers &amp; Images</title>
    <link href="https://blog.crazyalu.com/2023/10/14/quill-day-29/"/>
    <id>https://blog.crazyalu.com/2023/10/14/quill-day-29/</id>
    <published>2023-10-14T07:32:26.000Z</published>
    <updated>2024-02-21T14:30:20.002Z</updated>
    
    <content type="html"><![CDATA[<p>昨天體驗了基本的行內格式 Blot 以及區塊格式 Blot，今天繼續實現類似 Medium 編輯器的最後四個部分，分別為分隔線、圖片、影片、以及推文的自訂功能實現。</p><h2 id="分隔線-Dividers"><a href="#分隔線-Dividers" class="headerlink" title="分隔線 (Dividers)"></a>分隔線 (Dividers)</h2><p>接下來的步驟中，我們將實作第一個所謂的「葉子 Blot (Leaf Blot) 」。不同於先前我們練習過的 Blot，這些主要是負責文本格式化—例如定義文字的外觀或調整排列，並實作<code>format()</code>方法。Leaf Blot 的主要職責則是提供特定的內容，並透過實作 <code>value()</code> 方法來達成。</p><p>Leaf Blot 可以是文本 (Text) 型態或嵌入 (Embed) 型態的 Blot。在本例中，我們會實作一個屬於嵌入型態的 Blot，即分隔線 (Divider)。值得注意的是，一旦 Embed Blot 建立，其內含的值將會是不可變的 (Immutable) 。因此，如果你需要變更這個 Blot 的內容，則必須先將其從文本中刪除，再重新插入新的內容。</p><p>首先我們新增一個 TS 檔當作 Leaf Blot 的練習，並加入 Divider 的 Blot：</p><pre><code class="typescript">import Quill from &#39;quill&#39;;const BlockEmbed = Quill.import(&#39;blots/block/embed&#39;);export class DividerBlot extends BlockEmbed &#123;  static blotName = &#39;myDivider&#39;;  static tagName = &#39;hr&#39;;&#125;</code></pre><p>我們的 click handler 呼叫了 <code>insertEmbed()</code> 方法，這個方法不像 <code>format()</code> 那麼方便可以確定、保存和恢復使用者的選擇區域。因此我們需要自行做一些額外的工作來維護這個選擇區域。此外，當我們嘗試在一個 Block 的中間插入一個 Block Embed 時，Quill 會自動為我們將該 Block 分割開來。為了讓這個行為更為明確，我們會在插入分隔線之前明確地插入一個換行符，以自行分割該 Block。</p><p>建立 DividerBlot 之後，回到 Component 註冊 DividerBlot 並新增 <code>addDivider</code> 方法：</p><pre><code class="typescript">registerBasicFormatting() &#123;  // ...  // Leaf blot  Quill.register(DividerBlot);&#125;addDivider() &#123;  const range = this.quillInstance.getSelection(true);  this.quillInstance.insertText(range.index, &#39;\n&#39;, Quill.sources.USER)  this.quillInstance.insertEmbed(    range.index + 1,    &#39;myDivider&#39;,    true,    Quill.sources.USER  );    this.quillInstance.setSelection(    &#123; index: range.index + 2, length: 0 &#125;,    Quill.sources.SILENT  );&#125;</code></pre><p>接著將對應的 button 加上事件綁定：</p><pre><code class="html">  &lt;button    type=&quot;button&quot;    title=&quot;divider&quot;    id=&quot;divider-button&quot;    (click)=&quot;addDivider()&quot;  &gt;    &lt;i class=&quot;fa fa-minus&quot;&gt;&lt;/i&gt;  &lt;/button&gt;</code></pre><p>輸入兩行 Hello World 之後，游標停留在第一行的 Hello 後面，並點擊加入分隔線，可以看到 HTML 被強制換行後加入分隔線：</p><p><img src="/2023/10/14/quill-day-29/20090749xs4eCKsO7y.png" alt="強制換行後加入分隔線"></p><h2 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h2><p>圖片的處理可以使用我們在建立 Link 和 Divider blots 時所學到的概念來新增。我們會使用一個物件作為圖片的值來展示如何被支援的。我們用於插入圖像的 click handler 直接帶入 hardcode 的內容來專注在插入圖片 Blot 的實現。</p><p>建立 ImageBlot，分別有 <code>create</code> 以及 <code>value</code> 兩個靜態方法：</p><pre><code class="typescript">export class ImageBlot extends BlockEmbed &#123;  static blotName = &#39;myImage&#39;;  static tagName = &#39;img&#39;;    static create(value: &#123; alt: string; url: string &#125;) &#123;    const node = super.create();    node.setAttribute(&#39;alt&#39;, value.alt);    node.setAttribute(&#39;src&#39;, value.url);    return node;  &#125;  static value(node: HTMLImageElement) &#123;    return &#123;      alt: node.getAttribute(&#39;alt&#39;),      url: node.getAttribute(&#39;src&#39;),    &#125;;  &#125;&#125;</code></pre><p>接著在 Component 加上插入圖片的 handler，並綁定到對應的 button：</p><pre><code class="html">&lt;button type=&quot;button&quot; title=&quot;image&quot; id=&quot;image-button&quot; (click)=&quot;addImage()&quot;&gt;  &lt;i class=&quot;fa fa-camera&quot;&gt;&lt;/i&gt;&lt;/button&gt;</code></pre><pre><code class="typescript">addImage() &#123;    const range = this.quillInstance.getSelection(true);    this.quillInstance.insertText(range.index, &#39;\n&#39;, Quill.sources.USER);    this.quillInstance.insertEmbed(      range.index + 1,      &#39;image&#39;,      &#123;        alt: &#39;Quill Cloud&#39;,        url: &#39;https://quilljs.com/0.20/assets/images/cloud.png&#39;,      &#125;,      Quill.sources.USER    );    this.quillInstance.setSelection(      &#123; index: range.index + 2, length: range.length &#125;,      Quill.sources.SILENT    );  &#125;</code></pre><p>看一下加入圖片後的效果：</p><p><img src="/2023/10/14/quill-day-29/20090749KoNw5w1Re2.png" alt="加入圖片後的效果"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天主要就兩個 Embed Blot 的實現，我們透過繼承 Quill 底下的 Parchment Embed Blot 來建立自定義的 Blot，對於 Quill 的方法及應用有比較深入的理解。 整體的實現上都是與 DOM 去做對應在編輯器中加入內容，因此都會經過 <code>Create()</code> 方法來新增 DOM，如果是簡單的 HTML，沒有太多的加工處理，則直接帶上 <code>blotNmae</code> 和 <code>tagName</code> 即可，按照官網文件的說明，Quill 的確也讓編輯器的內容與結構盡可能的單純易懂。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>這個週末是魔物獵人 Now 的社群日，有期間限定的櫻火龍，貌似對拿弓箭的玩家來說是不錯的裝備材料收集，準備好今天的文章之後，等等就要出去晃晃，希望不會太快就把藥水喝完 XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/02143d0c84a93c8c4a6e254fb52e083bc6a100e4">今日份的練習</a></li><li><a href="https://quilljs.com/guides/cloning-medium-with-parchment/#dividers">Cloning Medium with Parchment - Quill (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10339493">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天體驗了基本的行內格式 Blot 以及區塊格式 Blot，今天繼續實現類似 Medium 編輯器的最後四個部分，分別為分隔線、圖片、影片、以及推文的自訂功能實現。&lt;/p&gt;
&lt;h2 id=&quot;分隔線-Dividers&quot;&gt;&lt;a href=&quot;#分隔線-Dividers&quot; clas</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 28：使用 Parchment 實現類似 Medium 的編輯器 - Basic Formatting &amp; myBlot</title>
    <link href="https://blog.crazyalu.com/2023/10/13/quill-day-28/"/>
    <id>https://blog.crazyalu.com/2023/10/13/quill-day-28/</id>
    <published>2023-10-13T14:53:54.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我們新增了一個元件並初始化 Quill 的核心，今天繼續實現 Medium 編輯器的練習。</p><h2 id="實作基礎格式"><a href="#實作基礎格式" class="headerlink" title="實作基礎格式"></a>實作基礎格式</h2><p>我們之前提到過，Inline 不貢獻任何格式。這是為 Inline 基礎類別所制定的例外，而不是規則。基本的 block Blot 和區塊級的元素 (Block level element) 的運作方式相同。<br>要實作粗體和斜體，我們只需要繼承 Inline，設定 blotName 和 tagName，並註冊到 Quill 中即可。有關繼承和靜態方法和變數的內容介紹可以參考 Parchment 的介紹。</p><pre><code class="typescript">import Quill from &#39;quill&#39;;const Inline = Quill.import(&#39;blots/inline&#39;);export class BoldBlot extends Inline &#123;  static blotName = &#39;myBold&#39;;  static tagName = &#39;strong&#39;;&#125;export class ItalicBlot extends Inline &#123;  static blotName = &#39;myItalic&#39;;  static tagName = &#39;em&#39;;&#125;</code></pre><p>這裡跟著 Medium 的範例使用 <code>Strong</code> 以及 <code>em</code> 標籤，但我們也可以使用 <code>b</code> 和 <code>i</code> 標籤。Quill 將使用 blot 的名稱當作格式名稱，透過註冊我們的 Blot，我們現在可以在新格式上使用 Quill 的完整 API：</p><pre><code class="typescript">ngAfterViewInit(): void &#123;  this.registerBasicFormatting();  this.quillInstance = new Quill(this.editorContainer.nativeElement);&#125;registerBasicFormatting() &#123;  Quill.register(BoldBlot);  Quill.register(ItalicBlot);&#125;insertText() &#123;  this.quillInstance.insertText(0, &#39;Test&#39;, &#123; myBold: true &#125;);&#125;formatText() &#123;  this.quillInstance.formatText(0, 4, &#39;myItalic&#39;, true);&#125;</code></pre><p>接著將按鈕的 <code>click</code> 事件加上，這邊為了示範方便，我們直接寫死一個 <code>true</code> 在程式裡面，這樣就會一直是加上格式的操作。在 App 中，我們可以使用 <code>getFormat()</code> 來尋找指定範圍內的文本格式，來決定是否新增或刪除格式。Toolbar 模組因為 Quill 已經實現了，就不在這重新實作。</p><p>兩個按鈕都點擊之後的效果如下：<br><img src="/2023/10/13/quill-day-28/20090749XSOo5OU7wF.png" alt="都點擊之後的效果"></p><h2 id="實作連結-Link"><a href="#實作連結-Link" class="headerlink" title="實作連結 (Link)"></a>實作連結 (Link)</h2><p>與其他格式（如粗體或斜體）不同，Link 需要存入更多資訊，特別是 URL。這主要影響到「Link blot」的兩個方面：建立和格式檢索。</p><ol><li><strong>建立（Creation）</strong>: 當建立一個 Link 時，除了表示它是一個 Link 外，還需要加上 URL。這通常會以字串的形式來表示。</li><li><strong>格式檢索（Format Retrieval）</strong>: 當需要找出或修改一個已存在的 Link 格式時，除了知道它是一個Link 外，我們還需要取得或修改 Link 的 URL。</li></ol><p>雖然 URL 通常以字串的型別存入，但也可以用其他方式來表示，例如以一個包含 URL Key value 的物件。這樣做可以允許我們加入其他的 Key&#x2F;Value 來定義一個連結，提供更多自定義的選項。</p><p>新增一個 Link Blot：</p><pre><code class="typescript">export class LinkBlot extends Inline &#123;  static blotName = &#39;myLink&#39;;  static tagName = &#39;a&#39;;  static create(value: string) &#123;    let node = super.create();    // Sanitize url value if desired    node.setAttribute(&#39;href&#39;, value);    // Okay to set other non-format related attributes    // These are invisible to Parchment so must be static    node.setAttribute(&#39;target&#39;, &#39;_blank&#39;);    return node;  &#125;  static formats(node: HTMLElement) &#123;    // We will only be called with a node already    // determined to be a Link blot, so we do    // not need to check ourselves    return node.getAttribute(&#39;href&#39;);  &#125;&#125;</code></pre><p>Component 加入新的註冊和方法：</p><pre><code class="typescript">registerBasicFormatting() &#123;  Quill.register(BoldBlot);  Quill.register(ItalicBlot);  Quill.register(LinkBlot);&#125;</code></pre><p>考慮到安全性，這裡我們可以在 <code>constructor</code> 注入 Angular 提供的 <code>DomSanitizer</code> “消毒” (sanitize)輸入的 URL 避免 XSS 問題發生：</p><pre><code class="typescript">constructor(private sanitizer: DomSanitizer) &#123;&#125;addLink() &#123;  const url = prompt(&#39;請輸入 URL&#39;);  const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);  this.quillInstance.format(&#39;myLink&#39;, safeUrl);&#125;</code></pre><p>接著嘗試選取文本內容，並點擊加入連結的按鈕，輸入網址後可以看到效果：</p><p><img src="/2023/10/13/quill-day-28/20090749DdXqJnTjSl.png" alt="加入連結效果"></p><h2 id="區塊引用-Blockquote-與標題-Headers"><a href="#區塊引用-Blockquote-與標題-Headers" class="headerlink" title="區塊引用 (Blockquote) 與標題 (Headers)"></a>區塊引用 (Blockquote) 與標題 (Headers)</h2><p>Blockquotes 繼承自 Block，這是基本的 Block Blot（一種自定義的文本塊）。與 Inline blots 不同的是，Block Blots 不能被嵌套。如果對同一範圍的文字套用多個 Block blots，它們不會互相包裹，而是會相互替換。也就是說，新套用的 Block Blot 會取代原有的 Block Blot。</p><p>建立 BlockquoteBlot：</p><pre><code class="typescript">const Block = Quill.import(&#39;blots/block&#39;);export class BlockquoteBlot extends Block &#123;  static blotName = &#39;myBlockquote&#39;;  static tagName = &#39;blockquote&#39;;&#125;</code></pre><p>註冊 Blot：</p><pre><code class="typescript">Quill.register(BlockquoteBlot);</code></pre><p>Header 的實作方式完全相同，只有一處不同：它可以由多個 DOM 元素表示。預設情況下，格式的值將成為 tagName，而不僅僅是 true。我們可以透過擴充 formats() 來自訂，類似於我們對連結所做的那樣：</p><pre><code class="typescript">export class HeaderBlot extends Block &#123;  static blotName = &#39;myHeader&#39;;  static tagName = [&#39;H1&#39;, &#39;H2&#39;];  static formats(node: HTMLElement) &#123;    return HeaderBlot.tagName.indexOf(node.tagName) + 1;  &#125;&#125;</code></pre><p>為了方便測試，加入 CSS 的部分：</p><pre><code class="scss">::ng-deep h1, ::ng-deep h2 &#123;  margin-top: 0.5em;  color: purple;&#125;::ng-deep blockquote &#123;  border-left: 4px solid #111;  padding-left: 1em;&#125;</code></pre><p>最後在 Component 加入 event function，再和 template 的 <code>click</code> 事件綁定：</p><pre><code class="typescript">addBlockquote() &#123;  this.quillInstance.format(&#39;myBlockquote&#39;, true);&#125;addHeader1() &#123;  this.quillInstance.format(&#39;myHeader&#39;, 1);&#125;addHeader2() &#123;  this.quillInstance.format(&#39;myHeader&#39;, 2);&#125;</code></pre><p>輸入不同段落的內容後，點擊按鈕試試看套用格式效果，可以看到對應的 HTML 元素也被成功加入了，並且套用了設定好的 CSS Style：</p><p><img src="/2023/10/13/quill-day-28/200907499JOpQmtui3.png" alt="套用了設定好的 CSS Style"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天嘗試跟著實現自訂的 Inline Blot 和 Block Blot，實際操作過一遍會比較有感覺，官方文件提供的範例是 JavaScript，那我們就直接以 Angular 的專案當作練習，以 Angular 的方式來實現對應的功能。對於自訂的 Blot 內容有進一步的理解，明天再接著練習後面的其他功能。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>轉眼間就來到第 28 天了，時間真的過的很快，也平安度過試用期(?)。但對於很多細節和產業的觀念還是持續學習中，白天工作內容的轟炸與考古，晚上則持續學習及寫文章做紀錄，上週的連假則是邊出去旅遊，回到住宿的地方後，繼續準備文章內容，腦袋裝了滿滿的東西。生活的節奏也比以往要快了許多，從進辦公室開始工作，回過神來就快下班了，除了充實，還是充實 XD…</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/0a2256e1d4601c4e5c8a388572cc03ce5c77e7ec">今日份的練習</a></li><li><a href="https://quilljs.com/guides/cloning-medium-with-parchment/">Cloning Medium with Parchment - Quill (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10338783">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天我們新增了一個元件並初始化 Quill 的核心，今天繼續實現 Medium 編輯器的練習。&lt;/p&gt;
&lt;h2 id=&quot;實作基礎格式&quot;&gt;&lt;a href=&quot;#實作基礎格式&quot; class=&quot;headerlink&quot; title=&quot;實作基礎格式&quot;&gt;&lt;/a&gt;實作基礎格式&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 27：使用 Parchment 實現類似 Medium 的編輯器 - 準備工作</title>
    <link href="https://blog.crazyalu.com/2023/10/12/quill-day-27/"/>
    <id>https://blog.crazyalu.com/2023/10/12/quill-day-27/</id>
    <published>2023-10-12T13:46:08.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>昨天透過 Parchement 新增了三種不同的 Attributor，今天來看要如何在編輯器上運用。官方文件介紹嘗試實現一個類似 Medium 的功能編輯器，今天就來逐步練習看看。</p><h2 id="實現-Medium-編輯器"><a href="#實現-Medium-編輯器" class="headerlink" title="實現 Medium 編輯器"></a>實現 Medium 編輯器</h2><p>為了提供一致的編輯體驗，我們需要同時具有一致的資料及可預測的行為，然而這兩項是 DOM 都沒有的。現代編輯器的解決方案是維護自己的文件模型來表示其內容。對於 Quill 來說，Parchment 就是這樣的一個解決方案。它在自己的 library 中有組織的架構，並有屬於自己的 API。透過 Parchment，我們就可以自定義 Quill 能夠識別的內容與格式，或者加入全新的格式。</p><p>在官網這份指南中，我們將使用 Parchment 和 Quill 提供的基礎模組來複製 Medium 上的編輯器。我們將從 Quill 的最基本架構開始，不涉及任何 Theme，額外的模組或格式。在這個基礎上，Quill 只能理解純文本。但跟著這份指南做到最後，連結，影片甚至推文都能被 Quill 所辨別。</p><h2 id="準備工作"><a href="#準備工作" class="headerlink" title="準備工作"></a>準備工作</h2><p>剛開始我們不使用 Quill，而只需要 <code>textarea</code> 及按鈕。並且將按鈕加上 event listener。文件的介紹是使用 jQuery 來實現，但我們就直接在 Angular 專案下來做這個練習囉。另外還需要  <a href="https://fonts.google.com/">Google Fonts</a> 和 <a href="https://fontawesome.io/">Font Awesome</a> 為練習的專案加上一些基本樣式。這些都和 Quill 或 Parchment 沒有直接關係，這部分就快速帶過。首先新增一個練習用的 Component，之後分別將 HTML 以及 CSS 加到 Component。</p><p>HTML ：</p><pre><code class="html">&lt;p&gt;medium-editor works!&lt;/p&gt;&lt;div #tooltipControls class=&quot;tooltip-controls&quot;&gt;  &lt;button id=&quot;bold-button&quot; (click)=&quot;formatBold()&quot;&gt;    &lt;i class=&quot;fa fa-bold&quot;&gt;&lt;/i&gt;  &lt;/button&gt;  &lt;button id=&quot;italic-button&quot;&gt;&lt;i class=&quot;fa fa-italic&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;link-button&quot;&gt;&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;blockquote-button&quot;&gt;&lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;header-1-button&quot;&gt;&lt;i class=&quot;fa fa-header&quot;&gt;&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/button&gt;  &lt;button id=&quot;header-2-button&quot;&gt;&lt;i class=&quot;fa fa-header&quot;&gt;&lt;/i&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;sidebar-controls&quot;&gt;  &lt;button id=&quot;image-button&quot;&gt;&lt;i class=&quot;fa fa-camera&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;video-button&quot;&gt;&lt;i class=&quot;fa fa-play&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;tweet-button&quot;&gt;&lt;i class=&quot;fa-brands fa-twitter&quot;&gt;&lt;/i&gt;&lt;/button&gt;  &lt;button id=&quot;divider-button&quot;&gt;&lt;i class=&quot;fa fa-minus&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/div&gt;&lt;textarea  class=&quot;editor-container&quot;  placeholder=&quot;Tell your story...&quot;  #editorContainer&gt;&lt;/textarea&gt;</code></pre><p>CSS：</p><pre><code class="scss">* &#123;  box-sizing: border-box;&#125;.editor-container &#123;  display: block;  font-family: &#39;Open Sans&#39;, Helvetica, sans-serif;  font-size: 1.2em;  height: 200px;  margin: 0 auto;  width: 450px;&#125;.tooltip-controls, .sidebar-controls &#123;  text-align: center;&#125; button &#123;  background: transparent;  border: none;  cursor: pointer;  display: inline-block;  font-size: 18px;  padding: 0;  height: 32px;  width: 32px;  text-align: center;&#125;button:active, button:focus &#123;  outline: none;&#125;</code></pre><p>Component 我們只加了一個 <code>formatBold</code> 方法來和 template 做事件綁定：</p><pre><code class="typescript">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; CommonModule &#125; from &#39;@angular/common&#39;;@Component(&#123;  selector: &#39;app-medium-editor&#39;,  standalone: true,  imports: [CommonModule],  templateUrl: &#39;./medium-editor.component.html&#39;,  styleUrls: [&#39;./medium-editor.component.scss&#39;],&#125;)export class MediumEditorComponent &#123;  formatBold() &#123;    alert(&#39;click!&#39;);  &#125;&#125;</code></pre><p>執行 <code>serve</code> 指令之後確認渲染的結果：</p><p><img src="/2023/10/12/quill-day-27/20090749CWYQwIo4Xl.png" alt="執行 `serve` 指令之後確認渲染的結果"></p><h2 id="加入-Quill-核心"><a href="#加入-Quill-核心" class="headerlink" title="加入 Quill 核心"></a>加入 Quill 核心</h2><p>接下來，我們將用 Quill 核心取代文字區域，去除主題、格式和無關模組。打開 Dev tool，在編輯器中輸入內容時檢查示範。可以看到 Parchment 文件的 base building block 正在執行中。</p><p>HTML 的部分，將剛才加入的 <code>textarea</code> 改成 <code>div</code> 並帶入範本參考變數 (Template Reference Variable) <code>editorContainer</code>， 例如：</p><pre><code class="html">&lt;div class=&quot;editor-container&quot; #editorContainer&gt;Tell your story...&lt;/div&gt;</code></pre><p>由於換成 <code>div</code>，所以 <code>editor-container</code> class 也有做了小更動：</p><pre><code class="scss">.editor-container &#123;  border: 1px solid #ccc;  font-family: &#39;Open Sans&#39;, Helvetica, sans-serif;  font-size: 1.2em;  height: 200px;  margin: 0 auto;  width: 450px;&#125;</code></pre><p>存檔重新整理之後，嘗試在編輯區域打字，可以看到 Quill 核心正在執行中：</p><p><img src="/2023/10/12/quill-day-27/20090749800mBZwczC.png" alt="在編輯區域打字"></p><p>就像 DOM 一樣，Parchment 文件是一個樹 (tree)。它的節點稱為 Blot，是 DOM 節點的抽象化。已經有一些 blot 已經為我們定義了，例如：Scroll, Block, Inline, Text 以及 Break。當我們輸入文字的時候，Text Blot 會與對應的 DOM 文字節點同步。而 Enter 則會建立一個新的 Block Blot 來處理。在 Parchment 中，可以有子項的 Blot 必須至少有一個子項，因此 Empty Block 會被 Break Blot 填滿。這使得處理樹葉 (leaves) 變得簡單且可預測。所有這一切都組織在 Root Scroll Blot 下。</p><p>這時我們無法僅透過輸入文本來觀察 Inline Blot，因為它​​不會為文件提供有意義的結構或格式。有效的 Quill 文件必須規範 (canonical) 且緊湊 (compact)。只有一棵有效的 DOM 樹可以表示給定的文件，並且該 DOM 樹包含最少數量的節點。</p><p>由於 <code>&lt;p&gt;&lt;span&gt;Text&lt;/span&gt;&lt;/p&gt;</code> 和 <code>&lt;p&gt;Text&lt;/p&gt;</code> 代表著相同的內容, 前者是無效的，Quill 的優化過程之一就是拆開 <code>&lt;span&gt;</code>. 同樣地，一旦我們加入格式，<code>&lt;p&gt;&lt;em&gt;Te&lt;/em&gt;&lt;em&gt;st&lt;/em&gt;&lt;/p&gt;</code> 和 <code>&lt;p&gt;&lt;em&gt;&lt;em&gt;Test&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;</code> 也是無效的，因為它們不是最緊湊的表示方式。</p><p>因為這些限制，<strong>Quill 無法支援任意 DOM 樹和 HTML 變更</strong>。但正如我們將看到的，這種結構提供的一致性和可預測性使我們能夠輕鬆建立豐富的編輯體驗。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天開始嘗試從無到有實現 Quill 的基本功能，官網文件介紹是使用 jQuery 當作範例，但因為我們主要是在 Angular 的專案上開發，所以範例的部分都融入了 Angular 元件的生命週期，使用起來更貼近實際的開發情況。明天繼續練習 Basic Formatting 以及自訂 blot 的部分。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天中午吃飯經過南港展覽館，看到人比平常還多就知道這週末有展期了，分別是世界貓咪博覽會，還有攝影器材暨影音創作設備展，台灣戶外用品展，共有三個展覽同步在今天開始，如果是貓奴、有在玩影音創作相關設備或是時常在露營的人，感覺進去錢包就會被榨乾 XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/5994068535154158c7fb31418ff6058ffeaf661e">今日份練習</a></li><li><a href="https://quilljs.com/guides/cloning-medium-with-parchment/">Cloning Medium with Parchment - Quill (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10338673">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天透過 Parchement 新增了三種不同的 Attributor，今天來看要如何在編輯器上運用。官方文件介紹嘗試實現一個類似 Medium 的功能編輯器，今天就來逐步練習看看。&lt;/p&gt;
&lt;h2 id=&quot;實現-Medium-編輯器&quot;&gt;&lt;a href=&quot;#實現-Mediu</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 26：關於 Pachment 的 Attributors</title>
    <link href="https://blog.crazyalu.com/2023/10/11/quill-day-26/"/>
    <id>https://blog.crazyalu.com/2023/10/11/quill-day-26/</id>
    <published>2023-10-11T14:30:57.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>之前有探討過 Parchment 與 Blot，而 Parchment 還有一個屬性器 (Atrributors)，今天就來看一下關於 Attributor 的介紹以及使用方式。</p><p>Attributor 是另一種更輕量的表示格式的方式。與其對應的就是 DOM attribute。就像 DOM 屬性與節點的關係一樣，屬性也屬於 Blot。在 Inline 或 Block blot 上呼叫 <code>formats()</code> 如果有對應的 DOM 節點以及 DOM 節點 <code>attribute</code> 則將回傳其表示的格式。</p><h2 id="Attributor-Class"><a href="#Attributor-Class" class="headerlink" title="Attributor Class"></a>Attributor Class</h2><p>首先我們來看一下 Attributor 的介面：</p><pre><code class="typescript">class Attributor &#123;  attrName: string;  keyName: string;  scope: Scope;  whitelist: string[];  constructor(attrName: string, keyName: string, options: AttributorOptions = &#123;&#125;);  add(node: HTMLElement, value: string): boolean;  canAdd(node: HTMLElement, value: string): boolean;  remove(node: HTMLElement);  value(node: HTMLElement);&#125;</code></pre><p>需要留意的地方是，自訂的 attributor 是 instance，而不是像 blot 一樣的 class 定義。與 Blot 相似，我們不會想要從頭開始建立，而是希望使用既有的 attributors 實現，例如基礎屬性器 (base Attributor)，類別屬性器 (Class Attributor) 或樣式屬性器 (Style Attributor)。另外我們也可以透過<a href="https://github.com/quilljs/parchment/tree/main/src/attributor">原始碼</a>來看 attributor 的實現，其實沒有很複雜。</p><h2 id="Attributor"><a href="#Attributor" class="headerlink" title="Attributor"></a>Attributor</h2><p>使用 Attributor 來表示格式：</p><pre><code class="typescript">const width = new Attributor(&#39;width&#39;, &#39;width&#39;);Quill.register(width);const imageNode = document.createElement(&#39;img&#39;);width.add(imageNode, &#39;200px&#39;);console.log(imageNode.outerHTML); // Will print &lt;img width=&quot;200px&quot;&gt;const value = width.value(imageNode); // Will return 200pxconsole.log(&#39;value&#39;, value); width.remove(imageNode);console.log(imageNode.outerHTML) // Will print &lt;img&gt;</code></pre><p>可以看到我們直接以 <code>new Attributor()</code> 的方法來新增一個實體化 <code>width</code> 屬性後，以 <code>Quill.register()</code> 註冊 attribute，並且呼叫 <code>add</code> 方法將屬性加到 <code>img</code> DOM 上。然後可以透過 <code>value()</code> 取得目標 DOM 的 <code>width</code>，最後使用 <code>remove()</code> 將 <code>width</code> 從 <code>imageNode</code> 刪除。</p><h2 id="Class-Attributor"><a href="#Class-Attributor" class="headerlink" title="Class Attributor"></a>Class Attributor</h2><p>使用 Class Attributor 的方式來表示格式：</p><pre><code class="typescript">const align = new ClassAttributor(&#39;align&#39;, &#39;blot-align&#39;);Quill.register(align);const node = document.createElement(&#39;div&#39;);align.add(node, &#39;right&#39;);console.log(node.outerHTML); // Will print &lt;div class=&quot;blot-align-right&quot;&gt;&lt;/div&gt;</code></pre><p>有別於上一個 <code>new Attributor()</code>，一樣是 <code>new</code> 但後面換成是 <code>ClassAttributor</code>，帶入指定的 DOM <code>attribute</code> 並自訂一個名稱 <code>blot-align</code>，一樣註冊後使用。也能呼叫 <code>add()</code> 將自訂的 class attributor 加到目標 DOM。</p><h2 id="Style-Attributor"><a href="#Style-Attributor" class="headerlink" title="Style Attributor"></a>Style Attributor</h2><p>使用 Style Attributor 的方式來表示格式：</p><pre><code class="typescript">const align = new StyleAttributor(&#39;align&#39;, &#39;text-align&#39;, &#123;  whitelist: [&#39;right&#39;, &#39;center&#39;, &#39;justify&#39;], // Having no value implies left align&#125;);Quill.register(align);const node = document.createElement(&#39;div&#39;);align.add(node, &#39;right&#39;);console.log(node.outerHTML); // Will print &lt;div style=&quot;text-align: right;&quot;&gt;&lt;/div&gt;</code></pre><p>這次則是在實體化的時候以 <code>new StyleAttributor</code> 來新增 attributor，一樣是操作 <code>text-align</code>，但這次加上了 <code>whitelist</code> 來表示合法的參數選項。沒有帶入值則代表 <code>left</code> 置左。在註冊之後呼叫 <code>add()</code> 方法並帶入 DOM 以及 <code>align</code> 的參數選項來套用。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天探討了 Parchment 的另一塊拼圖，Attributor，提供一個文本格式套用的簡易方式。一開始嘗試練習發現奇怪怎麼會出現找不到的錯誤，看了一下 sourcecode 才發現原來實現的方式已經換了，但 Github 的 repositroy README 還是古早的實現方式。這時只能看原始碼才能知道要怎麼使用了。</p><p>我們可以透過 Base Atrributor，Class Atrributor，以及 Style Attributor 來實現不同方式的文本樣式套用，並且 Attributor 也提供了幾個方法例如 <code>add()</code>，<code>value()</code>，<code>remove()</code> 等方法取得與操作對應的 blot 來編輯文本樣式。之後再研究看看如何將 attributor 應用到編輯器中來套用文本樣式。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>連假後上班的第一天，果然精神不是很好，儘管前一晚已經盡量提早躺平，但起床後還是有沒充滿電的感覺，由於台北住處附近不好停車，所以果斷的把車開回宜蘭停放，所以今天早上是從宜蘭搭車到台北，想說國光客運到南港展覽館離上班地點最近，沒想到七點半到轉運站，要能上車得要等到八點整的班次，到辦公室就都九點了，看來如果是從宜蘭到台北的話還要再更早一點到才行了QQ</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/a719545a2167edbda7099c5ff37222bf4c25bc30">今日份的練習</a></li><li><a href="https://github.com/quilljs/parchment/">quilljs&#x2F;parchment (github.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10338302">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有探討過 Parchment 與 Blot，而 Parchment 還有一個屬性器 (Atrributors)，今天就來看一下關於 Attributor 的介紹以及使用方式。&lt;/p&gt;
&lt;p&gt;Attributor 是另一種更輕量的表示格式的方式。與其對應的就是 DOM a</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 25：ngx-quill 介紹</title>
    <link href="https://blog.crazyalu.com/2023/10/10/quill-day-25/"/>
    <id>https://blog.crazyalu.com/2023/10/10/quill-day-25/</id>
    <published>2023-10-10T13:41:07.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>前面 14 天都在看 Quill Editor 的官方文件，突然想起我的主題還是要跟 Angular 有一點關係，除了直接在 Angular 引入 Quill 之外，其實也有方便的第三方套件可以使用，也就是 ngx-quill。</p><p>在 Angular 專案中，有時候會需要用到第三方套件，為了要能順利的融入 Angular 的世界，我們會需要額外的處理與封裝，讓套件使用體驗可以更 Angular。而使用 ngx-quill 的好處如下：</p><h2 id="資料與事件綁定"><a href="#資料與事件綁定" class="headerlink" title="資料與事件綁定"></a>資料與事件綁定</h2><p>我們都知道 Angular 使用 data binding 以及 event binding 作為核心特性之一，使用 ngx-quill 可以方便的透過綁定的方式來維護資料的狀態以及編輯器的互動等功能。</p><h2 id="模組化及相依性注入"><a href="#模組化及相依性注入" class="headerlink" title="模組化及相依性注入"></a>模組化及相依性注入</h2><p>Angular 專案中，我們透過 module (目前更推薦使用 standalone component)，以及相依性注入 ( Dependency Injection ) 作為管理各種服務和元件的方式。ngx-quill 也是按照 Angular 的模組化及相依性注入的設計模式來建立。使其更容易整合到既有的 Angular App 中。</p><h2 id="表單控制"><a href="#表單控制" class="headerlink" title="表單控制"></a>表單控制</h2><p>Angular 有很強大的表單 module，包括了：<code>template-driven forms</code> 以及 <code>reactive Forms</code>。ngx-quill 可以輕鬆的整合到 Angular 的表單系統中，讓我們能使用 Angular 的驗證、狀態追蹤等功能。</p><h2 id="安裝與使用"><a href="#安裝與使用" class="headerlink" title="安裝與使用"></a>安裝與使用</h2><p>首先我們一樣透過 <code>npm install</code> 來安裝 <code>ngx-quill</code>：</p><pre><code class="bash">npm install ngx-quill --savenpm install @types/quill@1.3.10</code></pre><p>另外需要注意的是，如果之前的練習有安裝到 <code>@types/quill</code> 的話，版本會是 <code>2.0.11</code>，這邊我們需要降版到 <code>1.3.10</code> 才不會導致編譯時的類型錯誤。</p><p>如果是全新的 Angular 專案，需要將 quill editor 的佈景主題 (theme) CSS Style 加到專案，例如：<br>要選用 <code>snow</code> 的主題，可以 import CSS 到 <code>styles.scss</code>：</p><pre><code class="scss">@import &#39;~quill/dist/quill.snow.css&#39;;</code></pre><p>也可以把 <code>node_modules/quill/dist/quill.snow.css</code> 加到 <code>angular.json</code> 或 Nx 的 <code>project.json</code> 的 <code>styles</code> 陣列中。</p><pre><code class="json">&quot;styles&quot;: [    &quot;node_modules/quill/dist/quill.snow.css&quot;,    &quot;src/styles.scss&quot;],</code></pre><p>安裝完畢之後，接著我們要將 <code>ngx-quill</code> 的 module 導入：</p><pre><code class="typescript">import &#123; QuillModule &#125; from &#39;ngx-quill&#39;;@NgModule(&#123;  imports: [    QuillModule.forRoot()  ],&#125;)export class AppModule &#123; &#125;</code></pre><p>Import 之後就可以直接在 template 使用這個元件：</p><pre><code class="html">&lt;quill-editor&gt;&lt;/quill-editor&gt;</code></pre><p>這時直接 <code>ng serve</code> 就可以看到有基本款的 Quill Editor 了。</p><h2 id="配置選項"><a href="#配置選項" class="headerlink" title="配置選項"></a>配置選項</h2><p>配置選項目前我們可以放在兩個地方，一個是在 template 的 component 屬性中，另一個則是在 import <code>QuillConfigModule.forRoot()</code> 的括號中帶入配置選項。</p><p>在 template 的 component 屬性加上 quill eidtor 的配置：</p><pre><code class="html">&lt;quill-editor  [modules]=&quot;&#123;    toolbar: [      [&#39;bold&#39;, &#39;italic&#39;],      [&#39;link&#39;, &#39;blockquote&#39;]    ]  &#125;&quot;  [theme]=&quot;&#39;snow&#39;&quot;&gt;&lt;/quill-editor&gt;</code></pre><p>透過 import <code>QuillConfigModule</code> 帶入配置：</p><pre><code class="typescript">import &#123; QuillConfigModule, QuillModule &#125; from &#39;ngx-quill&#39;;@NgModule(&#123;  imports: [    QuillModule.forRoot(),    QuillConfigModule.forRoot(&#123;      modules: &#123;        toolbar: [          [&#39;bold&#39;, &#39;italic&#39;],          [&#39;link&#39;, &#39;blockquote&#39;],        ],      &#125;,    &#125;),  ],&#125;)export class AppModule &#123; &#125;</code></pre><h3 id="Standalone-元件"><a href="#Standalone-元件" class="headerlink" title="Standalone 元件"></a>Standalone 元件</h3><p><code>ngx-quill</code> 也支援 standalone 的功能，可以直接使用 <code>provideQuillConfig</code> 方法進行配置，例如在 <code>main.ts</code> 的 <code>bootstrapApplication</code> 呼叫時，將配置加入到 <code>providers</code>：</p><pre><code class="typescript">import &#123; provideQuillConfig &#125; from &#39;ngx-quill/config&#39;;bootstrapApplication(AppComponent, &#123;  providers: [    provideQuillConfig(&#123;      modules: &#123;        syntax: true,        toolbar: [          [&#39;bold&#39;, &#39;italic&#39;],          [&#39;link&#39;, &#39;blockquote&#39;],        ],      &#125;    &#125;)  ]&#125;);</code></pre><p>此時的 <code>AppComponent</code> 對應的 standalone 設定如下：</p><pre><code class="typescript">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; QuillModule &#125; from &#39;ngx-quill&#39;;@Component(&#123;  selector: &#39;app-root&#39;,  templateUrl: &#39;./app.component.html&#39;,  styleUrls: [&#39;./app.component.scss&#39;],  standalone: true,  imports: [QuillModule],&#125;)export class AppComponent &#123;// ...&#125;</code></pre><h2 id="與-Angular-Form-整合"><a href="#與-Angular-Form-整合" class="headerlink" title="與 Angular Form 整合"></a>與 Angular Form 整合</h2><p>有時候我們要確認編輯器的狀態，以根據需求進行像是表單驗證，或是否修改過等相關的操作，這時候可以搭配 Angular Form module 加到 <code>ngx-quill</code> 就能快速的實現表單操作與驗證的需求。例如以下的範例，搭配 <code>import</code> 對應的 <code>FormsModule</code> 或 <code>ReactiveFormsModule</code> 就能使用了：</p><pre><code class="html">&lt;!-- Reactive Forms --&gt;&lt;form [formGroup]=&quot;myForm&quot;&gt;  &lt;quill-editor formControlName=&quot;editorContent&quot;&gt;&lt;/quill-editor&gt;&lt;/form&gt;&lt;!-- Template-driven Forms --&gt;&lt;quill-editor [(ngModel)]=&quot;editorContent&quot; name=&quot;editorContent&quot;&gt;&lt;/quill-editor&gt;</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p><code>ngx-quill</code> 作為 Quill 的 Angular wrapper，為 Angular 開發者提供了一個更方便、更“Angular化”的方式來使用編輯器。從簡單的安裝配置到與 Angular Forms 的整合，可以省略掉前期的設定流程，直接無痛加入並使用。之後再繼續看 ngx-quill 的其他介紹內容。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>連假的最後一天，運氣還不錯，儘管前一天晚上豪大雨，但今天的天氣就陰陰的沒有下雨，是涼爽舒服的，去了傳統藝術中心，這次也待了比較多的時間在裡面度過，跟著導覽員去看各種不同的傳統文化，也看了很帥的霹靂布袋戲人偶，不論什麼時候看，精細的程度都不輸專業的模型，但真的很大尊，家裡空間不夠的收一尊就很極限了 XD 期待下次再來逛逛，會有不同的展覽內容。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://github.com/KillerCodeMonkey/ngx-quill">KillerCodeMonkey&#x2F;ngx-quill: Angular (&gt;&#x3D;2) components for the Quill Rich Text Editor (github.com)</a><br><a href="https://snyk.io/advisor/npm-package/@types/quill">@types&#x2F;quill - npm Package Health Analysis | Snyk</a></p><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10337742">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面 14 天都在看 Quill Editor 的官方文件，突然想起我的主題還是要跟 Angular 有一點關係，除了直接在 Angular 引入 Quill 之外，其實也有方便的第三方套件可以使用，也就是 ngx-quill。&lt;/p&gt;
&lt;p&gt;在 Angular 專案中，有</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 24：讀 Quill Editor API 技術文件 - Clipboard 與 Syntax Highlighter Module</title>
    <link href="https://blog.crazyalu.com/2023/10/09/quill-day-24/"/>
    <id>https://blog.crazyalu.com/2023/10/09/quill-day-24/</id>
    <published>2023-10-09T15:51:20.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>連假第三天，終於來到最後的兩個章節，Clipboard &amp; Syntax Highlighter Module。因為篇幅比較沒有那麼多，所以就放在一起看了。</p><p>剪貼簿 ( Clipboard Module )，負責處理 Quill Editor 與外部 App 之間的複製、剪下與貼上的操作。Clipboard module 提供了一組預設的判斷邏輯處理貼上的內容，並且我們能進一步通過加入自定義的匹配器（matcher）來調整或擴充這些預設行為。例如：我們可以讓特定的 HTML 標籤或文字段落在貼上時有特殊的格式或行為。</p><p>剪貼簿會通過後序遍歷（post-order）相應的 DOM 樹來處理貼上的 HTML，從而建構所有子樹的 Delta 表示形式。在每個子節點，matcher 函數會被呼叫，並傳入 DOM 節點和到目前為止的 Delta 處理，這樣可以讓 matcher 回傳一個修改過的 Delta。要能操作好 matcher，就需要熟悉和理解 Delta。</p><h2 id="可用的-API"><a href="#可用的-API" class="headerlink" title="可用的 API"></a>可用的 API</h2><h4 id="addMatcher"><a href="#addMatcher" class="headerlink" title="addMatcher"></a>addMatcher</h4><p>將自定義 matcher 新增到 clipboard module。使用 <code>nodeType</code> 的 matcher 會先被呼叫，按照它們被加入的順序，另一個是使用 CSS selector 的 matcher，也是按照被加入的順序。<code>nodeType</code> 可能是 <code>Node.ELEMENT_NODE</code> 或 <code>Node.TEXT_NODE</code>。</p><p>方法：</p><pre><code class="typescript">addMatcher(selector: String, (node: Node, delta: Delta) =&gt; Delta)addMatcher(nodeType: Number, (node: Node, delta: Delta) =&gt; Delta)</code></pre><p>範例：</p><pre><code class="typescript">quill.clipboard.addMatcher(Node.TEXT_NODE, function(node, delta) &#123;  return new Delta().insert(node.data);&#125;);// Interpret a &lt;b&gt; tag as boldquill.clipboard.addMatcher(&#39;B&#39;, function(node, delta) &#123;  return delta.compose(new Delta().retain(delta.length(), &#123; bold: true &#125;));&#125;);</code></pre><h4 id="dangerouslyPasteHTML"><a href="#dangerouslyPasteHTML" class="headerlink" title="dangerouslyPasteHTML"></a>dangerouslyPasteHTML</h4><p>在指定的索引位置將由 HTML 片段表示的內容插入到編輯器中。該片段會被剪貼簿的匹配器解釋，這可能不會產生完全相同的輸入 HTML。如果沒有提供插入索引，則會覆蓋整個編輯器的內容。來源可能是 “user”、”api” 或 “silent”。</p><p>不正確的處理 HTML 可能會導致跨站腳本攻擊（XSS），而未能正確清理 (sanitize) 則是引發網站漏洞的主要原因之一。明確的命名這個方法，以確保我們能注意到使用這個方法可能涉及的風險。這個命名方式也遵循了 React 框架的例子，React 也有類似的概念，如 <code>dangerouslySetInnerHTML</code> 用來提醒開發者必須謹慎操作。</p><p>方法：</p><pre><code class="typescript">dangerouslyPasteHTML(html: String, source: String = &#39;api&#39;)dangerouslyPasteHTML(index: Number, html: String, source: String = &#39;api&#39;)</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello!&#39;);quill.clipboard.dangerouslyPasteHTML(5, &#39; &lt;b&gt;World&lt;/b&gt;&#39;);// 編輯器的 HTML 文本內容會是 &#39;&lt;p&gt;Hello &lt;strong&gt;World&lt;/strong&gt;!&lt;/p&gt;&#39;;</code></pre><h2 id="Clipboard-配置設定"><a href="#Clipboard-配置設定" class="headerlink" title="Clipboard 配置設定"></a>Clipboard 配置設定</h2><h4 id="matchers"><a href="#matchers" class="headerlink" title="matchers"></a>matchers</h4><p>可以將 <code>matcher</code> 陣列傳遞到剪貼簿的配置選項中。這些將附加在 Quill 內建的 <code>matcher</code> 之後。</p><pre><code class="typescript">var quill = new Quill(&#39;#editor&#39;, &#123;  modules: &#123;    clipboard: &#123;      matchers: [        [&#39;B&#39;, customMatcherA],        [Node.TEXT_NODE, customMatcherB]      ]    &#125;  &#125;&#125;);</code></pre><h3 id="Syntax-Highlighter-Module"><a href="#Syntax-Highlighter-Module" class="headerlink" title="Syntax Highlighter Module"></a>Syntax Highlighter Module</h3><p>語法高亮模組（Syntax Highlighter Module）在 Quill Editor 中用於增強程式碼區塊內容（Code Block）格式。它會自動檢測並套用語法高亮效果，且依賴於 highlight.js 函式庫來解析和標記程式碼區塊。</p><p>我們可以根據需求來配置 highlight.js。不過，Quill 要求 <code>useBR</code> 的選項必須設為 false。</p><p>範例：</p><pre><code class="typescript">&lt;!-- 引入 highlight.js 樣式表 --&gt;&lt;link href=&quot;highlight.js/monokai-sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- 引入 highlight.js 函式庫 --&gt;&lt;script href=&quot;highlight.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;hljs.configure(&#123;   // optionally configure hljs  languages: [&#39;javascript&#39;, &#39;ruby&#39;, &#39;python&#39;]&#125;);var quill = new Quill(&#39;#editor&#39;, &#123;  modules: &#123;    syntax: true,              // Include syntax module    toolbar: [[&#39;code-block&#39;]]  // Include button in toolbar  &#125;,  theme: &#39;snow&#39;&#125;);&lt;/script&gt;</code></pre><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>剪貼簿（Clipboard）模組在 Quill Editor 中負責處理與外部應用間的複製、剪下和貼上操作。它提供了一套預設行為來解析貼上的內容，並允許開發者透過自定義 <code>matcher</code> 來進一步調整這些行為。這些 <code>matcher</code> 可以按照它們被加入的順序來進行呼叫，而在貼上 HTML 時，剪貼簿會後序遍歷對應的 DOM 樹來創建一個 Delta 表示形式。</p><p>基於安全性考慮，提供了一個 <code>dangerouslyPasteHTML</code> 的API，用在確認安全的操作情境下插入  HTML。剪貼簿模組不僅提供了彈性的自訂方式，也考慮到貼上內容的安全處理，使 Quill 更靈活實用。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>儘管昨日發現前一晚停車時刮到了輪拱板金，心情受到一些影響之外，整體的行程還不錯，在金車威士忌酒廠待了一整天，雖然之前也去過幾次，但都沒有導覽員，這次趁著人多時，有導覽員的服務，也學到不少威士忌的一些觀念，今天出發前就發了這篇文章，預計會去傳統藝術中心，今天天氣看起來很不錯，要多喝水避免被太陽曬昏頭了 XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/715fbbeecb81d6092729b55db7edce578ed9fa18">今日份的練習</a></li><li><a href="https://quilljs.com/docs/modules/clipboard/">Clipboard Module - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10337353">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;連假第三天，終於來到最後的兩個章節，Clipboard &amp;amp; Syntax Highlighter Module。因為篇幅比較沒有那麼多，所以就放在一起看了。&lt;/p&gt;
&lt;p&gt;剪貼簿 ( Clipboard Module )，負責處理 Quill Editor 與外部 </summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 23：讀 Quill Editor API 技術文件 - History Module</title>
    <link href="https://blog.crazyalu.com/2023/10/08/quill-day-23/"/>
    <id>https://blog.crazyalu.com/2023/10/08/quill-day-23/</id>
    <published>2023-10-08T15:21:15.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>昨天泡了溫泉，休息一下，繼續看 History module。<br>History module 主要保存文本操作紀錄與處理與 Quill 的 undo 和 redo。<br>有以下的選項可以使用：</p><h2 id="配置設定參數"><a href="#配置設定參數" class="headerlink" title="配置設定參數"></a>配置設定參數</h2><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>預設值：<code>1000</code> </p><p>設定在指定秒數內更改合併成一個更改紀錄。例如當 <code>delay</code> 設為 <code>0</code> 時，幾乎每個字元都會記錄成一次更改，因此使用 <code>undo</code> 就只會取消一個字元。當 <code>delay</code> 設置為 1000 時，<code>undo</code> 將會撤銷最後 1000 毫秒內發生的所有變更。</p><h3 id="maxStack"><a href="#maxStack" class="headerlink" title="maxStack"></a>maxStack</h3><p>預設值：<code>100</code></p><p>設定歷史操作紀錄堆疊的最大值。與 <code>delay</code> 選項合併的變更算是一次變更操作。</p><h3 id="userOnly"><a href="#userOnly" class="headerlink" title="userOnly"></a>userOnly</h3><p>預設值：<code>false</code></p><p>預設的情況下，無論 <code>source</code> 是 <code>user</code> 或是透過 <code>api</code> 的方式進行的所有變更。都視為同等的操作，並且變更可以從 <code>history</code> <code>redo</code>&#x2F;<code>undo</code>。如果 <code>userOnly</code> 設為 <code>true</code>，則只會處理使用者的變更。</p><pre><code class="typescript">const quill = new Quill(&#39;#editor&#39;, &#123;  modules: &#123;    history: &#123;      delay: 2000,      maxStack: 500,      userOnly: true    &#125;  &#125;,  theme: &#39;snow&#39;&#125;);</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>清除 <code>history</code> 的所有堆疊紀錄</p><p>方法：</p><pre><code class="typescript">clear()</code></pre><p>範例：</p><pre><code class="typescript">quill.history.clear();</code></pre><h3 id="cutoff-實驗性"><a href="#cutoff-實驗性" class="headerlink" title="cutoff (實驗性)"></a>cutoff (實驗性)</h3><p>通常短時間內連續進行的變更，我們可以透過 <code>delay</code> 設置來合併成為一次歷史紀錄，以便觸發更多的 <code>undo</code> 的變更。使用 <code>cutoff</code> 將重置合併窗口，以便呼叫 <code>cutoff</code> 之前和之後的更改不會被合併。</p><p>方法：</p><pre><code class="typescript">cutoff()</code></pre><p>範例：</p><pre><code class="typescript">quill.history.cutoff();</code></pre><h3 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h3><p>取消最後一次的變更操作。</p><p>方法：</p><pre><code class="typescript">undo()</code></pre><p>範例：</p><pre><code class="typescript">quill.history.undo();</code></pre><h3 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h3><p>如果上次的操作是 <code>undo</code>，則還原 <code>undo</code>。</p><p>方法：</p><pre><code class="typescript">redo()</code></pre><p>範例：</p><pre><code class="typescript">quill.history.redo();</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天嘗試了初始化的時候加入 History module 的配置設定參數，另外也透過按鈕的方式來呼叫 history module 的 API，也能觀察到其 history stack 的變化，不過目前 <code>@types/quill</code> 的 history 版本似乎沒看到有 history module 的其他屬性，只有加上 API 的定義而已，感覺可以再提一個新 PR 了 XD</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>昨天運氣不錯，搭客運回宜蘭牽車沒遇到塞車，順利的開車到新竹接朋友出發到宜蘭，這聽起來有點瘋狂，我只是喜歡開車而已XD 不過到了住宿的停車場，因為是機械式的，沒注意到後面兩側還有塗上黃色的支撐桿，今天早上出發前才看到右後輪拱有擦到 Orz 前一晚停車時原本以為是機械車位的地板阻尼之類的作動聲，沒想到是磨擦聲，儘管是老車了，也多少有一些擦傷，但還是免不了會心痛 QQ，找時間再去買幾支板金補漆筆塗一下了，畢竟輪拱最邊緣的地方有一小部分都看到銀色的部分，應該是底漆也有刮掉了 (哭</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/b399895e47cf5221bdaed7ef89fe4401b31b477c">今日份的練習</a></li><li><a href="https://quilljs.com/docs/modules/history/">History Module - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10336767">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天泡了溫泉，休息一下，繼續看 History module。&lt;br&gt;History module 主要保存文本操作紀錄與處理與 Quill 的 undo 和 redo。&lt;br&gt;有以下的選項可以使用：&lt;/p&gt;
&lt;h2 id=&quot;配置設定參數&quot;&gt;&lt;a href=&quot;#配置設定參數</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 22：讀 Quill Editor API 技術文件 - Keyboard Module (下)</title>
    <link href="https://blog.crazyalu.com/2023/10/07/quill-day-22/"/>
    <id>https://blog.crazyalu.com/2023/10/07/quill-day-22/</id>
    <published>2023-10-07T04:25:20.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>連假的第一天，今天繼續看 Keyboard module 的 <code>context</code> 剩下的參數以及設定相關的介紹。</p><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>當使用者的游標從開始移動到 <code>offset</code> 指定的特定的位置則觸發 handler，例如：當 <code>offset</code> 為 <code>3</code> 時，只有使用者選擇的文字或是游標是在同一行的第三個字元位置開始，才會執行對應的 handler。另外執行的時機點是在使用者輸入內容的時候就已經判定的，因此使用者如果在第 3 個字元時按下按鍵輸入文字，則 handler 會在文字輸入之前就被執行。</p><pre><code class="typescript">quill.keyboard.addBinding(  &#123; key: &#39;o&#39; &#125;,  &#123; offset: 2 &#125;, // 當游標在第3個字元前面時觸發  (range, context) =&gt; &#123;    // 插入特殊符號的代碼    quill.insertText(range.index, &#39;★★★&#39;);  &#125;);</code></pre><h3 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h3><p>一個正則表達式（Regex）屬性，用於指定必須與使用者選擇的區域或游標開始位置之前的文字比對的模式。換句話說，當該正則表達式匹配到使用者選擇開始位置前方的文字時，相關的處理函數（handler）才會被觸發。例如，當使用者輸入一個 <code>@</code> 符號，然後按下 <code>k</code> 時，這個 handler 會被觸發。<code>prefix: /@$/</code> 確保了只有當游標（或選取範圍）前方是 <code>@</code> 符號時，這個 handler 才會執行：</p><pre><code class="typescript">quill.keyboard.addBinding(&#123; key: &#39;k&#39; &#125;, &#123;  prefix: /@$/, // 前置文本必須是 @&#125;, (range, context) =&gt; &#123;  // 這裡實現你的自定義邏輯，例如彈出一個用戶列表以供選擇  console.log(&quot;觸發了 @ 符號的自定義行為&quot;);&#125;);</code></pre><p><code>context.prefix</code> 在這個例子中會是 <code>@</code>，因為它包含了選擇開始位置之前的整個文字區塊。如此一來，我們就可以在使用者輸入 <code>@</code> 符號後進行特定操作，像是顯示一個下拉清單讓使用者選擇名稱。</p><h3 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h3><p>和 <code>prefix</code> 的概念相同，只是比對的位置是使用者選擇的內容或游標的位置的後面開始。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>預設的情況下，Quill 內建幾個實用的按鍵綁定，例如使用 Tab 鍵進行縮排。我們可以在初始化時加入自訂的按鍵綁定。</p><p>有些綁定對於防止瀏覽器的危險預設行為（如 Enter 鍵和 Backspace 鍵）是必要的。不能移除這些綁定以恢復到瀏覽器的原生行為。然而，由於在配置中指定的綁定會在 Quill 的預設綁定之前運行，您可以處理特殊情況並將其傳播給 Quill。</p><p>使用 <code>quill.keyboard.addBinding</code> 加入綁定不會在 Quill 的預設綁定之前運行，因為到那時預設綁定已經被加入。</p><p>每個綁定配置必須包含鍵（key）和處理器（handler）選項，並且可以選擇性地包括任何 <code>context</code> 選項。</p><pre><code class="typescript">const bindings = &#123;  // 這將覆蓋名為 &#39;tab&#39; 的預設綁定  tab: &#123;    key: 9,    handler: function() &#123;      // 處理 Tab 鍵    &#125;  &#125;,  // 沒有名為 &#39;custom&#39; 的預設綁定，  // 因此這將會被新增，而不會覆蓋任何內容  custom: &#123;    key: &#39;B&#39;,    shiftKey: true,    handler: (range, context) =&gt; &#123;      // 處理 Shift + B    &#125;  &#125;,  // 當按 Backspace 鍵並且格式為 list 時  list: &#123;    key: &#39;backspace&#39;,    format: [&#39;list&#39;],    handler: (range, context) =&gt; &#123;      if (context.offset === 0) &#123;        // 若在 list 的第一個字元上按 Backspace，        // 則移除該列表        this.quill.format(&#39;list&#39;, false, Quill.sources.USER);      &#125; else &#123;        // 否則，傳給 Quill 做預設處理        return true;      &#125;    &#125;  &#125;&#125;;// 初始化 Quill，並指定 keyboard module 的綁定var quill = new Quill(&#39;#editor&#39;, &#123;  modules: &#123;    keyboard: &#123;      bindings: bindings    &#125;  &#125;&#125;);</code></pre><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>和 DOM event 相同，Quill key binding 在每次比對時都會阻擋呼叫，因此為一個非常普通的按鍵綁定一個複雜的 handler 不是一個好的實現方式。在套用像是滑鼠移動或卷軸滾動的 DOM 事件時，盡可能的套用性能較好的實現以確保一定品質的使用者體驗。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>這兩天探討了 Quill 的 Keyboard module，讓我們可以自定義鍵盤事件的處理。Quill 的 keyboard module 主要有兩種用途：</p><ol><li>綁定格式化快捷鍵：比如 “Ctrl + B” 可以讓選中的文字變粗。</li><li>防止瀏覽器的一些預設行為：這樣可以確保應用程式的穩定性與使用者體驗。</li></ol><p>我們也了解如何使用不同的 <code>context</code> 參數來更精細的控制 handler 的觸發時機，包含游標的位置、目前使用中的格式、以及前後緊鄰的文本內容等。</p><p>此外，keyboard module 也提供了豐富的設定選項，讓我們可以在初始化時加入自訂的綁定，或是覆蓋Quill 的預設綁定。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天午餐後整理一下文章，晚一點就要出發去載朋友來宜蘭玩了，希望不要塞車塞得太嚴中 XD。昨天看了同事的分享會 Feedback，看到很多有趣的回應。其中還有提到下班後學習這件事，我認為學習是屬於個人的事情，至於有沒有要求下班後學習這件事，最終決定權還是在自己手上。若真的有興趣的而且學到之後能讓自己在上班的過程更順暢也能克服一些挑戰，我想這個學習過程應該是相當精彩的，儘管最後發現也許是個坑，但這都是成長的一部分。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/be03de30380a0ae188fee3c97890ec9b6d5b0cbd">今日份的練習</a></li><li><a href="https://quilljs.com/docs/modules/keyboard/#offset">Keyboard Module - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10335867">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;連假的第一天，今天繼續看 Keyboard module 的 &lt;code&gt;context&lt;/code&gt; 剩下的參數以及設定相關的介紹。&lt;/p&gt;
&lt;h3 id=&quot;offset&quot;&gt;&lt;a href=&quot;#offset&quot; class=&quot;headerlink&quot; title=&quot;offse</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 21：讀 Quill Editor API 技術文件 - Keyboard Module (上)</title>
    <link href="https://blog.crazyalu.com/2023/10/06/quill-day-21/"/>
    <id>https://blog.crazyalu.com/2023/10/06/quill-day-21/</id>
    <published>2023-10-06T14:28:19.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>今天來看 Keyboard module 的章節。</p><p>Keyboard module 支援特定 context 中鍵盤事件的自訂行為。Quill 使用 Keyboard module 來綁定格式化快捷鍵並防止一些瀏覽器副作用。</p><h2 id="Key-Bindings"><a href="#Key-Bindings" class="headerlink" title="Key Bindings"></a>Key Bindings</h2><p>Keyboard handler 綁訂到特定的按鍵與修飾鍵。<code>key</code> 是 JavaScript event 的 key code，但也允許英文字母與數字鍵，以及常用的按鍵的字串縮寫設定。常見的修飾鍵例如：<code>metaKey</code>，<code>ctrl</code>，<code>shift</code>，以及 <code>alt</code> 等。另外 <code>shortKey</code> 是指特定平台的修飾鍵，像是 MacOS 上的 <code>metaKey</code>，以及 Linux 和 Windows 上的 <code>ctrlKey</code>。</p><p>我們可以將指定的按鍵和修飾鍵綁定到一個 handler。當這個鍵被按下時，handler 就會被執行，並將使用者選擇的範圍傳入以及綁定到 keyboard module 當下的 instance：</p><pre><code class="typescript">quill.keyboard.addBinding(&#123;  key: &#39;B&#39;,  shortKey: true&#125;, function(range, context) &#123;  quill.formatText(range, &#39;bold&#39;, true);&#125;);// addBinding 也能只帶入一個參數，並加上 handlerquill.keyboard.addBinding(&#123;  key: &#39;B&#39;,  shortKey: true,  handler: function(range, context) &#123;    quill.formatText(range, &#39;bold&#39;, true);  &#125;&#125;);</code></pre><p>這個範例是當使用者按下 <code>B</code> 鍵加上修飾鍵（Mac 上的 <code>metaKey</code> 或 Windows 和 Linux 上的 <code>ctrlKey</code>）時，選取的文字會變粗體。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>我們還可以設定更多的條件，讓 handler 只在特定的情境下被呼叫。例如，當使用者選擇的是一個空行或者是列表項目時，才會觸發相對應的 handler：</p><pre><code class="typescript">// 如果使用者在 list 或 blockquote 的開頭按了 ctrl + d,// 則刪除 list 或 blockquote 的格式quill.keyboard.addBinding(  &#123; key: &#39;d&#39;, shortKey: true &#125;,  &#123;    collapsed: false,    format: [&#39;blockquote&#39;, &#39;list&#39;],    offset: 0,  &#125;,  function (range, context) &#123;    console.log(&#39;backspace pressed&#39;);    if (context.format.list) &#123;      quill.format(&#39;list&#39;, false);    &#125; else &#123;      quill.format(&#39;blockquote&#39;, false);    &#125;  &#125;);</code></pre><p>不過需要注意的地方是，當編輯器初始化之後才加入的 keyboard binding，需要確認內建的部分是否也有監聽，否則會因為按鍵事件發生時逐條比對條件的關係，就被前面的規則代為執行了。例如 <code>backspace</code> 的 <code>keycode</code> 是 <code>8</code>：<br><img src="/2023/10/06/quill-day-21/20090749Cy3B9odY5Z.png" alt="被前面的規則代為執行"></p><h2 id="Context-的參數"><a href="#Context-的參數" class="headerlink" title="Context 的參數"></a>Context 的參數</h2><h3 id="collapsed"><a href="#collapsed" class="headerlink" title="collapsed"></a>collapsed</h3><p>如果為 <code>true</code> 則當使用者的游標停在編輯器上，在沒有選擇任何文字的情況下觸發 handler。<code>collapsed</code> 翻成中文是收折的意思，但實際上就是指游標停在編輯器上並沒有選取任何文字的狀態。</p><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>如果為 <code>true</code>，當使用者的游標在一行空白的時候會觸發。設為 <code>false</code> 則代表非空行，另外當 <code>empty</code> 為 <code>true</code> 時，意思就是 <code>collapsed</code> 也要是 <code>true</code>，且 <code>offset</code> 必須是 <code>0</code>，這樣才是真正完全的一行空白。<br>例如當使用者換行的時候加上一個星星符號：</p><pre><code class="typescript">quill.keyboard.addBinding(&#123; key: &#39;enter&#39; &#125;, &#123;  empty: true  // 只在空行觸發&#125;, function(range, context) &#123;  // 插入特殊符號的代碼  this.editor.insertText(range.index, &#39;★&#39;);&#125;);</code></pre><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p><code>format</code> 這個參數用來控制 handler 在哪些特定的格式條件下會被觸發。</p><ul><li>當 <code>format</code> 是一個陣列時，如果當前活動（active）的格式中包含陣列裡面指定的任何一種格式，則會觸發 handler：</li></ul><pre><code class="typescript">quill.keyboard.addBinding(&#123; key: Keyboard.keys.ENTER &#125;, &#123;  format: [&#39;bold&#39;, &#39;italic&#39;] // 只要文字是粗體或斜體，處理函數就會觸發&#125;, function(range, context) &#123;  // 插入特殊符號的代碼  this.editor.insertText(range.index, &#39;★&#39;);&#125;);</code></pre><ul><li>當 <code>format</code> 是一個物件：所有指定的格式條件必須全部滿足，handler 才會觸發。</li></ul><pre><code class="typescript">quill.keyboard.addBinding(&#123; key: Keyboard.keys.ENTER &#125;, &#123;  format: &#123;    bold: true,    italic: true  &#125; // 當文字是粗體且斜體，處理函數才會觸發&#125;, function(range, context) &#123;  // 插入特殊符號的代碼  this.editor.insertText(range.index, &#39;★&#39;);&#125;);</code></pre><p>在任何情況下，<code>context</code> 參數的 <code>format</code> 屬性都會是一個物件，其中包含了所有當前活動的格式。這個物件的結構和 <code>quill.getFormat()</code> 回傳的結構是相同的。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天研究了 Quill 的 keyboard module，並了解如何加入自訂的 keyboard binding，也看到 <code>context</code> 的內容有哪些可以讓我們運用，明天接著看 <code>context</code> 其他的參數介紹。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天下班前，不小心把弄了一陣子的 Git stash 給 drop 掉了，然後又因為是在 Git Graph 上執行，所以也沒有留意到 hash 的部分，當下真的有 BBQ 的感覺，不死心的我花了一點時間研究，總算找到解法，第一次使用 <code>git fsck</code>，搭配 sh 腳本執行，把碎片找回來從裡面去翻之前改過的程式片段，找到後來改的內容，趕快把 hash 記下來，接著 apply，逝去的青春終於又回來了(誤。這故事給了我一個教訓，以後還是乖乖建 commit 吧…Orz</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/37337ce44f6a8659a39be3107e739b032d3e9373">今日份的練習</a></li><li><a href="https://quilljs.com/docs/modules/keyboard/">Keyboard Module - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10335585">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天來看 Keyboard module 的章節。&lt;/p&gt;
&lt;p&gt;Keyboard module 支援特定 context 中鍵盤事件的自訂行為。Quill 使用 Keyboard module 來綁定格式化快捷鍵並防止一些瀏覽器副作用。&lt;/p&gt;
&lt;h2 id=&quot;Key-B</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 20：讀 Quill Editor API 技術文件 - Toolbar Module</title>
    <link href="https://blog.crazyalu.com/2023/10/05/quill-day-20/"/>
    <id>https://blog.crazyalu.com/2023/10/05/quill-day-20/</id>
    <published>2023-10-05T13:58:34.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>今天開始第一個內建 module 的介紹，在第六天的時候我們就已經介紹如何自訂工具列，這篇就當作複習，跟著技術文件介紹來練習體驗。</p><p>工具列模組 (Toolbar module) 可以讓使用者輕鬆的將文本內容套用格式。Toolbar 除了初始化設置要開啟的功能後直接渲染，我們也可以自行定義 container 內容以及工具列功能的處理器 (handler)。</p><h2 id="Toolbar-module-設定"><a href="#Toolbar-module-設定" class="headerlink" title="Toolbar module 設定"></a>Toolbar module 設定</h2><p>Toolbar 的設定方式可分為兩種，一種是指定 toolbar 的容器 (container)，並視需求加上 HTML 控制項以及對應的處理器 (handler)，另一種則是直接使用陣列來設置。</p><p>透過指定 container 的設置方式：</p><pre><code class="html">&lt;p&gt;toolbar-practice works!&lt;/p&gt;&lt;div #myToolbar&gt;&lt;/div&gt;&lt;div #quillContainer&gt;&lt;/div&gt;</code></pre><pre><code class="typescript">@ViewChild(&#39;quillContainer&#39;) quillContainer!: ElementRef;@ViewChild(&#39;myToolbar&#39;) myToolbar!: ElementRef;quill!: Quill;ngAfterViewInit(): void &#123;    this.quill = new Quill(this.quillContainer.nativeElement, &#123;       modules: &#123;         toolbar: &#123;           container: this.myToolbar.nativeElement,           handlers: &#123;             bold: (value: boolean) =&gt; &#123;              console.log(&#39;value&#39;, value);              this.quill.format(&#39;bold&#39;, value);            &#125;,           &#125;        &#125;       &#125;     &#125;);&#125;</code></pre><p><code>toolbar</code> 也可直接給 <code>container</code> 的 id <code>selector</code>，這裡我們直接用 <code>template reference</code>：</p><pre><code class="typescript">const quill = new Quill(this.quillContainer.nativeElement, &#123;     modules: &#123; // Equivalent to &#123; toolbar: &#123; container: &#39;#toolbar&#39; &#125;&#125;         toolbar: this.myToolbar.nativeElement     &#125; &#125;);</code></pre><p>可以看到直接指定 <code>container</code> 之後，就可以直接渲染，但因為沒有設定要放哪些功能按鈕在工具列上，所以現在看到是還沒有任何按鈕的：</p><p><img src="/2023/10/05/quill-day-20/200907490cqE545H5z.png" alt="現在看到是還沒有任何按鈕"></p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>工具列的控制項可以帶入控制項名稱的陣列或自定義 HTML 容器來指定。<br>從基本的陣列來設定 <code>toolbar</code> 開始：</p><pre><code class="typescript">const toolbarOptions = [&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strike&#39;]; this.quill = new Quill(this.quillContainer.nativeElement, &#123;     modules: &#123;         toolbar: toolbarOptions     &#125; &#125;);</code></pre><h3 id="控制項分組與自定義"><a href="#控制項分組與自定義" class="headerlink" title="控制項分組與自定義"></a>控制項分組與自定義</h3><p>控制項也能放在巢狀陣列來表示設定分組，這樣可以將同一組的控制項放在 <code>className</code> 為 <code>ql-formats</code> 的 <code>&lt;span&gt;</code> 標籤下以提供佈景主題利用，例如在佈景主題 <a href="https://quilljs.com/docs/themes/#snow/"><code>snow</code></a>) 時，就會在這些分組間加上間距，方便使用者進行操作：</p><pre><code class="typescript">const toolbarOptions = [[&#39;bold&#39;, &#39;italic&#39;], [&#39;link&#39;, &#39;image&#39;]];</code></pre><p>另外可以使用一個物件來指定自定義值的按鈕，並將格式名稱作為 key：</p><pre><code class="typescript">const toolbarOptions = [&#123; &#39;header&#39;: &#39;3&#39; &#125;];</code></pre><p>上面這個範例會在工具列上加入一個按鈕，這個按鈕代表的是 <code>header</code> 格式，並且按鈕會套用 <code>3</code> 這個自定義的值。換句話說，當點擊這個按鈕時，選定的文字會變成第三級標題 <code>&lt;h3&gt;</code>。</p><h2 id="下拉選單"><a href="#下拉選單" class="headerlink" title="下拉選單"></a>下拉選單</h2><p>下拉選單也是透過物件來定義，但與其他元素不同的地方在於，這裡會用一個陣列來存入所有可能的選項值。下拉選單選項的視覺表現（例如文字標籤或顏色）是由 CSS 來控制的。</p><p>例如，設定字體大小 <code>size</code> 的選項：</p><pre><code class="typescript">// Note false, not &#39;normal&#39;, is the correct value // quill.format(&#39;size&#39;, false) removes the format, // allowing default styling to work const toolbarOptions = [ &#123; size: [ &#39;small&#39;, false, &#39;large&#39;, &#39;huge&#39; ]&#125; ];</code></pre><p><code>size</code> 陣列中的 <code>false</code> 是用於移除格式，也就是把文字的大小回到預設的狀態。</p><h2 id="佈景主題和預設值"><a href="#佈景主題和預設值" class="headerlink" title="佈景主題和預設值"></a>佈景主題和預設值</h2><p>某些佈景主題，例如 Snow，會為下拉選單（如顏色和背景格式）提供預設值。當設定空的陣列在 <code>color</code> 或 <code>background</code> 時， <a href="https://quilljs.com/docs/themes/#snow/">Snow</a> 將預設提供 35 種顏色選項：</p><pre><code class="typescript">const toolbarOptions = [     [&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;, &#39;strike&#39;], // toggled buttons     [&#39;blockquote&#39;, &#39;code-block&#39;],         [&#123; &#39;header&#39;: 1 &#125;, &#123; &#39;header&#39;: 2 &#125;], // custom button values     [&#123; &#39;list&#39;: &#39;ordered&#39;&#125;, &#123; &#39;list&#39;: &#39;bullet&#39; &#125;],     [&#123; &#39;script&#39;: &#39;sub&#39;&#125;, &#123; &#39;script&#39;: &#39;super&#39; &#125;], // 升冪與降冪    [&#123; &#39;indent&#39;: &#39;-1&#39;&#125;, &#123; &#39;indent&#39;: &#39;+1&#39; &#125;], // 縮排與減少縮排    [&#123; &#39;direction&#39;: &#39;rtl&#39; &#125;], // text direction         [&#123; &#39;size&#39;: [&#39;small&#39;, false, &#39;large&#39;, &#39;huge&#39;] &#125;], // custom dropdown     [&#123; &#39;header&#39;: [1, 2, 3, 4, 5, 6, false] &#125;],         [&#123; &#39;color&#39;: [] &#125;, &#123; &#39;background&#39;: [] &#125;], // dropdown 從 theme 獲取預設值     [&#123; &#39;font&#39;: [] &#125;],     [&#123; &#39;align&#39;: [] &#125;],         [&#39;clean&#39;] // 移除格式 ]; this.quill = new Quill(this.quillContainer.nativeElement, &#123;     modules: &#123;         toolbar: toolbarOptions     &#125;,     theme: &#39;snow&#39; &#125;);</code></pre><h2 id="進階客製化（Advanced-Customization）"><a href="#進階客製化（Advanced-Customization）" class="headerlink" title="進階客製化（Advanced Customization）"></a>進階客製化（Advanced Customization）</h2><p>如果需要對工具列更多的客製化，也能直接用 HTML 來手動創建工具列。只需要將 DOM 元素或選擇器傳遞給 Quill 即可。<code>ql-toolbar</code> 類會被添加到工具列容器中，而 Quill 會自動為具有 <code>ql-$&#123;format&#125;</code> 格式名稱的 <code>&lt;button&gt;</code> 和 <code>&lt;select&gt;</code> 元素附加對應的內建 handler。</p><pre><code class="html">&lt;!-- Create toolbar container --&gt; &lt;div #myToolbar&gt;&lt;!-- Add font size dropdown --&gt;     &lt;select class=&quot;ql-size&quot;&gt;        &lt;option value=&quot;small&quot;&gt;&lt;/option&gt;        &lt;!-- Note a missing, thus falsy value, is used to reset to default --&gt;        &lt;option selected&gt;&lt;/option&gt;        &lt;option value=&quot;large&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;huge&quot;&gt;&lt;/option&gt;    &lt;/select&gt;    &lt;!-- Add a bold button --&gt;    &lt;button class=&quot;ql-bold&quot;&gt;&lt;/button&gt;    &lt;!-- Add subscript and superscript buttons --&gt;     &lt;button class=&quot;ql-script&quot; value=&quot;sub&quot;&gt;&lt;/button&gt;    &lt;button class=&quot;ql-script&quot; value=&quot;super&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;div #quillContainer&gt;&lt;/div&gt; &lt;!-- Initialize editor with toolbar --&gt; </code></pre><pre><code class="typescript">this.quill = new Quill(this.quillContainer.nativeElement, &#123;     modules: &#123;         toolbar: this.myToolbar.nativeElement     &#125; &#125;); </code></pre><h2 id="自訂按鈕（Custom-Buttons）"><a href="#自訂按鈕（Custom-Buttons）" class="headerlink" title="自訂按鈕（Custom Buttons）"></a>自訂按鈕（Custom Buttons）</h2><p>當我們提供自己的 HTML 元素作為 Quill 的工具列時，Quill 會尋找特定的輸入元素來綁定功能。然而，除了 Quill 會自動識別和處理的元素外，你仍然可以加入和設計與 Quill 無關的自定義輸入元素。這些自定義的輸入元素可以和 Quill 的元素共存，且不會產生衝突。</p><pre><code class="html">&lt;div #myToolbar&gt;&lt;!-- Add buttons as you would before --&gt;    &lt;button class=&quot;ql-bold&quot;&gt;&lt;/button&gt;    &lt;button class=&quot;ql-italic&quot;&gt;&lt;/button&gt;    &lt;!-- But you can also add your own --&gt;    &lt;button class=&quot;custom-button&quot; (click)=&quot;doSomething()&quot;&gt;do something&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;editor&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="typescript">this.quill = new Quill(this.quillContainer.nativeElement, &#123;    modules: &#123;        toolbar: this.myToolbar.nativeElement    &#125;&#125;); </code></pre><h2 id="處理器-Handler"><a href="#處理器-Handler" class="headerlink" title="處理器 (Handler)"></a>處理器 (Handler)</h2><p>工具列的控制項預設會套用或移除格式，但我們也可以用自定義的 handler 來取代行為，例如顯示外部的使用者介面。<br>Handler function 會綁定到工具列，並且傳入輸入元素的 <code>value</code> 屬性。如果相對應的格式是非啟動狀態，則會傳入 <code>false</code>。加入自定義的 handler 會覆寫預設的工具列和主題行為。</p><pre><code class="typescript">const toolbarOptions = &#123;  handlers: &#123;    // handlers 物件會與預設的 handler 物件合併    link: (value: string) =&gt; &#123;      if (value) &#123;        const href = prompt(&#39;Enter the URL&#39;);        this.quill.format(&#39;link&#39;, href);      &#125; else &#123;        this.quill.format(&#39;link&#39;, false);      &#125;    &#125;,  &#125;&#125;this.quill = new Quill(this.quillContainer.nativeElement, &#123;  modules: &#123;    toolbar: toolbarOptions  &#125;&#125;);// Handler 也可以在初始化之後加入const toolbar = this.quill.getModule(&#39;toolbar&#39;);toolbar.addHandler(&#39;image&#39;, showImageUI);</code></pre><p>在上面的範例，為 <code>link</code> 格式定義了一個 custom handler。當使用者點擊工具列的連結按鈕時，會彈出一個提示框可以輸入URL。當使用者輸入URL 則會把選取的文字變成一個連結。反之當使用者取消操作會移除文字的連結格式。另外，可以在 Quill 初始化之後，動態地加入更多的 handler，如 <code>showImageUI</code> 這個函數用來處理圖像插入的 UI。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Quill 在初始化的時候，就算沒有給任何的 toolbar 設定，也會提供預設的功能選項直接使用，設定 toolbar 主要有兩種方式：</p><ol><li>使用 HTML 設置功能按鈕並指定 toolbar 的 <code>container</code><ul><li>Quill 會依照 <code>ql-*</code> class 名稱的 HTML 帶入對應的內建功能</li></ul></li><li>使用 toolbar options 陣列設置需要的功能<ul><li>不需要額外給定 HTML 或 container 即可初始化後渲染到 Quill 容器上</li></ul></li></ol><p>透過這些方式，我們可以靈活設計和調整 Quill 編輯器的工具列來滿足各種需求。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天對於北北基桃來說是個再正常不過的上班日了，但不知道為啥就沒有上班的氛圍，我想應該是新竹以南的夥伴們都在家防颱吧。沒有會議的一天可以完全專注的在開發工作上，雖然過程也遇到一些意外的挑戰，但還好都有初步解決了。明天還有一天班，之後就要好好充電休息一下，但還是要持續發文到 15 號了，希望扛的住…XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/cc354e601455a78eb7e63d82e711b31c67733d03">今日份的練習</a></li><li><a href="https://quilljs.com/docs/modules/toolbar/">Toolbar Module - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10334843">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天開始第一個內建 module 的介紹，在第六天的時候我們就已經介紹如何自訂工具列，這篇就當作複習，跟著技術文件介紹來練習體驗。&lt;/p&gt;
&lt;p&gt;工具列模組 (Toolbar module) 可以讓使用者輕鬆的將文本內容套用格式。Toolbar 除了初始化設置要開啟的功能後</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 19：讀 Quill Editor API 技術文件 - Modules</title>
    <link href="https://blog.crazyalu.com/2023/10/04/quill-day-19/"/>
    <id>https://blog.crazyalu.com/2023/10/04/quill-day-19/</id>
    <published>2023-10-04T14:19:19.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>明天北北基桃沒有放颱風假，大家上班注意安全。<br>今天開始進到 Module 的章節。</p><p>Module 允許 Quill 的操作行為與功能實現客製化。有幾個官方支援的模組可供選擇，其中一些還有額外的配置選項和API。目前官網列出支援的模組有：<code>Toolbar</code>，<code>Keyboard</code>，<code>History</code>，<code>Clipboard</code>，以及<code>Syntax Highlighter</code>。各章節也都會提到如何使用以及有哪些 API 可供操作。</p><p>要啟用模組只需要把要使用的模組加到 Quill 的配置中即可：</p><pre><code class="typescript">const quill = new Quill(&#39;#editor&#39;, &#123;     modules: &#123;         &#39;history&#39;: &#123; // Enable with custom configurations             &#39;delay&#39;: 2500,             &#39;userOnly&#39;: true         &#125;,         &#39;syntax&#39;: true // Enable with default configuration     &#125; &#125;);</code></pre><p>Clipboard，Keyboard 和 History 模組是 Quill 所必需的，不需要明確設定就預設在裡面了，但也可以像其他模組一樣進行設定。</p><h2 id="繼承-Extending"><a href="#繼承-Extending" class="headerlink" title="繼承 (Extending)"></a>繼承 (Extending)</h2><p>模組也可以繼承和重新註冊，替換掉原本的模組。甚至原本預設內建的必要模組也能重新註冊來做替換。例如繼承 clipboard 模組並自訂一些功能：</p><pre><code class="typescript">const Clipboard = Quill.import(&#39;modules/clipboard&#39;); const Delta = Quill.import(&#39;delta&#39;); class PlainClipboard extends Clipboard &#123;     convert(html = null) &#123;         if (typeof html === &#39;string&#39;) &#123;             this.container.innerHTML = html;         &#125;         let text = this.container.innerText;         this.container.innerHTML = &#39;&#39;;         return new Delta().insert(text);     &#125; &#125; Quill.register(&#39;modules/clipboard&#39;, PlainClipboard, true); // Will be created with instance of PlainClipboard const quill = new Quill(&#39;#editor&#39;);</code></pre><p>上面這個範例只是為了解釋 module 提供的可能性。單純用既有模組提供的 API 或 config 通常會更容易些。在這個 <code>clipboard</code> 模組擴充的操作範例中，用現有的 <code>addMatcher</code> 其實就能夠滿足大部分的情境需求了。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天介紹了 Quill 的 module，強調其客製化，以及可繼承並擴展。Quill 內建了許多豐富的 module，讓我們可以按照需求選擇和配置。繼承的部分則允許開發者擴充新功能並替換原有的模組，同時也提到單純使用既有的 API 或設定也許就能滿足大部分的需求。在這個章節，我們了解如何利用 module 來啟用 Quill 的功能，並依照實際需求進行繼承及擴充自訂功能，之後來介紹並研究一下第三方的開源套件要如何使用，以及他們是如何實現自訂功能的。應該能有不少收穫。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>最近上下班的運氣都還不錯，儘管有下雨，但出門跟下班回家的這段時間都是無雨的，今天又去了整復保養一下，然後再去看中醫，弄得時間有點晚。這次的颱風感覺也是來者不善，放颱風假就乖乖待在家，看點書追個劇也好。我明天要繼續去上班了 QQ</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://quilljs.com/docs/modules/">Modules - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10334295">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;明天北北基桃沒有放颱風假，大家上班注意安全。&lt;br&gt;今天開始進到 Module 的章節。&lt;/p&gt;
&lt;p&gt;Module 允許 Quill 的操作行為與功能實現客製化。有幾個官方支援的模組可供選擇，其中一些還有額外的配置選項和API。目前官網列出支援的模組有：&lt;code&gt;Too</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 18：讀 Quill Editor API 技術文件 - Extension</title>
    <link href="https://blog.crazyalu.com/2023/10/03/quill-day-18/"/>
    <id>https://blog.crazyalu.com/2023/10/03/quill-day-18/</id>
    <published>2023-10-03T15:10:17.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>今天接著看 Extension 的部分，顧名思義就是和擴充功能相關的 API 使用。</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>提供除錯用的靜態方法，可以開啟指定層級的 log 訊息，例如：<code>error</code>，<code>warn</code>，<code>log</code>，或 <code>info</code>。<br>傳入 <code>true</code> 等同於傳入 <code>log</code>，傳入 <code>false</code> 則是關閉所有 log 訊息。</p><p>方法：</p><pre><code class="typescript">Quill.debug(level: String | Boolean)</code></pre><p>範例：</p><pre><code class="typescript">Quill.debug(&#39;info&#39;);</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>將指定的擴充功能或模組引入 Quill。</p><p>方法：</p><pre><code class="typescript">Quill.import(path): any</code></pre><p>範例：</p><pre><code class="typescript">const Parchment = Quill.import(&#39;parchment&#39;);const Delta = Quill.import(&#39;delta&#39;);const Toolbar = Quill.import(&#39;modules/toolbar&#39;);const Link = Quill.import(&#39;formats/link&#39;);// 類似 ES6 的 import 語法: `import Link from &#39;quill/formats/link&#39;;`</code></pre><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>用於註冊 module、theme 或 format。可以讓我們擴充和自定義 Quill 的功能。註冊執行之後可以使用 <code>Quill.import</code> 獲取。使用路徑前綴 ‘formats&#x2F;‘、’modules&#x2F;‘ 或 ‘themes&#x2F;‘ 分別註冊 <code>formats</code>、<code>modules</code> 或 <code>themes</code>。對於 <code>format</code>，可以直接帶入且路徑將自動生成。也會覆蓋掉具有相同路徑的定義。</p><p>方法：</p><pre><code class="typescript">Quill.register(format: Attributor | BlotDefinintion, supressWarning: Boolean = false)Quill.register(path: String, def: any, supressWarning: Boolean = false)Quill.register(defs: &#123; [String]: any &#125;, supressWarning: Boolean = false)</code></pre><p>範例：</p><pre><code class="typescript">// 自訂一個空 moduleconst Module = Quill.import(&#39;core/module&#39;);class CustomModule extends Module &#123;&#125;Quill.register(&#39;modules/custom-module&#39;, CustomModule);</code></pre><p><code>register</code> 方法使 Quill 的功能更加彈性和可擴展，允許開發人員自定義格式、模組和主題，進而更滿足特定的應用需求。</p><blockquote><p>註冊之後要留意一下初始化的 <code>options</code> 裡面是否也有加入 custom-module!</p></blockquote><h2 id="addContainer"><a href="#addContainer" class="headerlink" title="addContainer"></a>addContainer</h2><p>在 Quill container 內加入一個容器元素 (container element) 並回傳，作為編輯器本身的同層元素。通常 Quill 模組都會有以 ql- 當作前綴的 class name。選擇性的參數 <code>refNode</code>，表示容器的插入位置應該在這個 <code>refNode</code> 之前。</p><p>方法：</p><pre><code class="typescript">addContainer(className: String, refNode?: Node): ElementaddContainer(domNode: Node, refNode?: Node): Element</code></pre><p>範例：</p><pre><code class="typescript">// 使用 className 加入 container elementconst container = quill.addContainer(&#39;ql-custom&#39;);// 使用 element reference 取得的 DOMaddContainerWithNativeElement(quill: Quill, nativeElement: HTMLElement) &#123;  const toolEditor = document.querySelector(&#39;.ql-editor&#39;);  console.log(&#39;addContainerWithNativeElement&#39;);  quill.addContainer(nativeElement, toolEditor);&#125;</code></pre><p>因為是在 Angular 專案上，所以建議還是使用 <code>@ViewChild</code> 取得 element reference，如此一來在套用 CSS 樣式的時候，就不需要再加上像 <code>::ng-deep</code> 的方式套用， 避免影響子元件樣式。 </p><p>使用 element reference 加上指定位置後的效果：<br><img src="/2023/10/03/quill-day-18/20090749iPB48sCf4t.png" alt="加上指定位置後的效果"></p><h2 id="getModule"><a href="#getModule" class="headerlink" title="getModule"></a>getModule</h2><p>取得已加入 Quill instance 的模組。</p><p>方法：</p><pre><code class="typescript">getModule(name: String): any</code></pre><p>範例：</p><pre><code class="typescript">const toolbar = quill.getModule(&#39;custom-module&#39;);</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Quill 在擴充功能的部分提供了幾個 API，包含了模組引入、除錯、註冊，也能加入自訂的 container element，並直接獲取 Quill instance 裡面指定的模組，稍微整理一下：</p><ul><li><code>debug</code>：靜態方法用於開啟不同層級的 log 訊息，有助於開發和除錯。</li><li><code>import</code>：用於回傳 Quill library、格式、模組或主題的靜態方法。使自定義和擴充變得非常靈活。</li><li><code>register</code>：這個方法允許註冊和定義自己的模組、主題或格式，提高 Quill 的可擴展性。</li><li><code>addContainer</code>：允許在 Quill 容器內新增容器元素，使得界面結構更加靈活。</li><li><code>getModule</code>：取得已經加入到編輯器的模組，有助於模組的管理和操控。</li></ul><p>大多數情況下，靜態方法如 <code>register</code> 和 <code>import</code> 最好是在 <code>new Quill()</code> 之前使用，以確保在初始化 Quill 時能夠使用這些自定義 module 或定義。而 <code>debug</code> 則可以根據實際需要來決定使用的時機。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天整理文章的時候，看到新聞上寫有颱風名字叫做小犬，於是心血來潮查了一下，別問我為什麼要查 XD<br>根據教育部的辭典網站釋義：<br>1)幼小的狗。清．孔尚任《桃花扇》第四○齣：「行到那舊院，何用輕敲，也不怕小犬哰哰。」<br>2)謙稱自己的兒子。《紅樓夢》第一三回：「待服滿後，親帶小犬到府叩謝。」也作「豚犬」、「豚兒」。</p><p>貌似第一次聽到這樣的命名，以前的名字都滿酷的，但最近的颱風名稱似乎有點微妙。聽說小犬一點都不小，大家要做好防颱措施阿…QQ</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/1c036fa131e6c06204b206da7b891c07ddf8fe27">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#extension">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10333603">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天接著看 Extension 的部分，顧名思義就是和擴充功能相關的 API 使用。&lt;/p&gt;
&lt;h2 id=&quot;debug&quot;&gt;&lt;a href=&quot;#debug&quot; class=&quot;headerlink&quot; title=&quot;debug&quot;&gt;&lt;/a&gt;debug&lt;/h2&gt;&lt;p&gt;提供除錯用的靜態</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 17：讀 Quill Editor API 技術文件 - Model</title>
    <link href="https://blog.crazyalu.com/2023/10/02/quill-day-17/"/>
    <id>https://blog.crazyalu.com/2023/10/02/quill-day-17/</id>
    <published>2023-10-02T14:13:17.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>今天看 Quill Editor 的 Model 技術文件介紹，根據文件的描述，語意版本控制（Semantic Versioning）不適用於實驗性 API，意思是 Model 的 API 目前仍然處於實驗性階段，代表未來可能會出現一些重大的改動而影響到 API 的穩定性，但可以先看過一遍並嘗試玩看看，未來有機會正式發布後，再考慮應用到正式的專案上。</p><p>透過 Model API 找到的 Blot 物件是 <code>LinkedList</code> 的資料結構：<br><img src="/2023/10/02/quill-day-17/20090749KPxBk00GWC.png" alt="LinkedList 的資料結構"></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>這是一個靜態方法，可以代入 DOM 節點並回傳 Quill 或 Blot Instance。在後者的情況下，對 <code>bubble</code> 參數傳入 true 會向上尋找目標 DOM 的祖先，直到找到相應的 Blot。</p><p>方法：</p><pre><code class="typescript">Quill.find(domNode: Node, bubble: boolean = false): Blot | Quill</code></pre><p>範例：</p><pre><code class="typescript">find(quill: Quill, container: HTMLElement) &#123;  // 帶入 container 尋找並取得 quill instance  const target = Quill.find(container);  console.log(&#39;target is quill instance&#39;, target === quill);  // 編輯器輸入連結文字並嘗試取得 link node  quill.insertText(0, &#39;Hello, World!&#39;, &#39;link&#39;, &#39;https://google.com&#39;);  const linkNode = container.querySelector(&#39;a&#39;);  const findLinkNode = Quill.find(linkNode!);  console.log(&#39;linkNode&#39;, findLinkNode);&#125;</code></pre><h2 id="getIndex"><a href="#getIndex" class="headerlink" title="getIndex"></a>getIndex</h2><p>回傳從文件開頭到帶入的 blot 之間的距離長度。</p><p>方法：</p><pre><code class="typescript">getIndex(blot: Blot): Number</code></pre><p>範例：</p><pre><code class="typescript">// 預先輸入文字並取得第 10 個字元的 blotquill.insertText(0, &#39;Hello, World!&#39;);const [line, offset] = quill.getLine(10);console.log(&#39;line&#39;, line);// 帶入 blot 取得 indexconst index = quill.getIndex(line); // index + offset should == 10console.log(&#39;index&#39;, index);console.log(&#39;offset&#39;, offset);</code></pre><h2 id="getLeaf"><a href="#getLeaf" class="headerlink" title="getLeaf"></a>getLeaf</h2><p>回傳文件中指定索引處的葉節點。<code>leaf</code> 通常指的是資料結構中的末端節點。</p><p>方法：</p><pre><code class="typescript">getLeaf(index: Number): Blot</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello Good World!&#39;);quill.formatText(6, 4, &#39;bold&#39;, true);const [leaf, offset] = quill.getLeaf(7);// leaf 會是帶有值為 &quot;Good&quot; 的葉節點// offset 應為 1，因為回傳的葉節點在索引 6 開始console.log(&#39;leaf&#39;, leaf);console.log(&#39;offset&#39;, offset);</code></pre><h2 id="getLine"><a href="#getLine" class="headerlink" title="getLine"></a>getLine</h2><p>回傳帶入的索引值指定位置的行 blot 。</p><p>方法：</p><pre><code class="typescript">getLine(index: Number): [Blot, Number]</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello\nWorld!&#39;);const [line, offset] = quill.getLine(7);// line 應為代表第二個 &quot;World!&quot; 行的 Block Blotconsole.log(&#39;line&#39;, line);// offset 為 1，因為 index 7 是在第二行 &quot;World!&quot; 的第二個字元console.log(&#39;offset&#39;, offset);</code></pre><h2 id="getLines"><a href="#getLines" class="headerlink" title="getLines"></a>getLines</h2><p>回傳指定位置的行中所包含的 blot。</p><p>方法：</p><pre><code class="typescript">getLines(index: Number = 0, length: Number = remaining): Blot[]getLines(range: Range): Blot[]</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello\nGood\nWorld!&#39;);quill.formatLine(1, 1, &#39;list&#39;, &#39;bullet&#39;);const lines = quill.getLines(2, 5);// 帶有 ListItem 與 Block Blot 的陣列// 代表是前面的兩行console.log(&#39;lines&#39;, lines);// 帶入 range 物件const linesByRange = quill.getLines(&#123; index: 8, length: 5 &#125;);console.log(&#39;linesByRange&#39;, linesByRange);</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天看了 Model 提供的 API，這些 API 主要是用於尋找 Blot 的相關應用，對於未來要自訂編輯器模組的功能實現時，可以利用這些 API 來找到正確的 Blot 並進一步處理文本內容，並且 Blot 提供的是 <code>linkedList</code> 的資料結構，因此對於節點的尋找來說，未來編輯內容量大的時候，可以研究看看<code>linkedList</code> 訪問節點的技巧來實現較有效率的搜尋處理。</p><p>Quill 的觀念基本上不難，較有挑戰的地方在於未來要滿足各種特殊需求時，要建立自訂的 Blot 必須要很清楚底層的生命週期與處理過程，這樣才能打造出高效且實用的自訂功能。找時間再繼續研究使用一些第三方套件，並嘗試了解這些套件是如何實現的，對於自訂功能的實現與優化應該會有所幫助。</p><p>再整理一下今天嘗試的 API：</p><ul><li><code>find</code>：透過 DOM 節點找到 Quill 或 Blot 實例。</li><li><code>getIndex</code>：回傳文件開頭到指定 blot 之間的距離。</li><li><code>getLeaf</code>：回傳指定索引處的葉節點。</li><li><code>getLine</code>：回傳指定索引位置的行 blot。</li><li><code>getLines</code>：回傳指定位置內的所有行 blot。</li></ul><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天突然意識到，這星期上完班之後，又是一個連續假期，這次的假期是要回宜蘭帶朋友四處走走，雖然住在宜蘭很久了，但還是有不少地方沒去過，趁這個機會去走走看。不過 11 月就完全沒有連假了，週末期望能好好的學習，並嘗試一些新玩意兒，還有買了一些書，要好好的閱讀一番。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/f888866bcc3263bcdec796f564cb2ba38521c13e">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#model">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10332980">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天看 Quill Editor 的 Model 技術文件介紹，根據文件的描述，語意版本控制（Semantic Versioning）不適用於實驗性 API，意思是 Model 的 API 目前仍然處於實驗性階段，代表未來可能會出現一些重大的改動而影響到 API 的穩定性，</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 16：讀 Quill Editor API 技術文件 - Events</title>
    <link href="https://blog.crazyalu.com/2023/10/01/quill-day-16/"/>
    <id>https://blog.crazyalu.com/2023/10/01/quill-day-16/</id>
    <published>2023-10-01T07:11:05.000Z</published>
    <updated>2024-02-21T14:30:19.998Z</updated>
    
    <content type="html"><![CDATA[<p>今天來看 Events 的部分，Event 的使用方式就和 JavaScript 的事件監聽一樣，透過指定的事件名稱來監聽，並執行指定的方法。</p><h3 id="text-change"><a href="#text-change" class="headerlink" title="text-change"></a>text-change</h3><p><code>text-change</code> 事件在編輯器的內容發生變化時觸發。變更的細節、變更前的內容，以及變更的來源都會提供出來。來源如果是使用者觸發的，則 <code>source</code> 就會是 <code>user</code>。例如：</p><ul><li>使用者在編輯器中打字</li><li>使用者使用工具列格式化文字</li><li>使用者使用快捷鍵回上一步</li><li>使用者使用作業系統拼寫校正</li></ul><p>特例：<br>觸發內容變更的事件雖然也可能透過 API 呼叫，但如果觸發的原因是使用者操作導致的話，<code>source</code> 仍然要設為 <code>user</code>。舉個例子：當使用者點擊工具欄的模組功能，該模組會呼叫變更的 API，但由於是使用者點擊所造成的變化，因此我們在模組呼叫 API 的時候，帶入的 <code>source</code> 仍必須是 <code>user</code>。 </p><p>Silent Source：<br>呼叫 API 處理的內容變更也可能以 <code>source</code> 為 <code>silent</code> 的方式觸發，在這樣的情況下 <code>text-change</code> 將不會被觸發。不建議這樣的操作，因為這樣可能會導致撤銷的堆疊紀錄異常，或是間接影響到需要完整內容變化紀錄的功能。</p><p>選取 (Selection) 發生變化<br>文字內容的變化可能導致 selection 變化（例如，打字使游標前進），但是在 <code>text-change</code> handler 執行期間，selection 尚未更新，加上原生瀏覽器的行為可能導致 selection 狀態不一致的情況。因此要使用 <code>selection-change</code> 或 <code>editor-change</code> 來處理 selection 更新比較穩定。</p><p>Callback Signature：</p><pre><code class="typescript">handler(delta: Delta, oldContents: Delta, source: String)</code></pre><p>範例：</p><pre><code class="typescript">quill.on(&#39;text-change&#39;, function(delta, oldDelta, source) &#123;  if (source == &#39;api&#39;) &#123;     console.log(&quot;An API call triggered this change.&quot;);  &#125; else if (source == &#39;user&#39;) &#123;     console.log(&quot;A user action triggered this change.&quot;);   &#125; &#125;);</code></pre><h3 id="selection-change"><a href="#selection-change" class="headerlink" title="selection-change"></a>selection-change</h3><p>當使用者或 API 造成 selection 變更時觸發，<code>range</code> 代表 selection 的邊界。當 <code>range</code> 為 <code>null</code> 時，表示 selection 的丟失（通常是由於編輯器失去焦點）。我們也可以在收到 <code>range</code> 是 <code>null</code> 的時候，用這個事件當作焦點變更的 event 確認。</p><p>API 造成的選取範圍變更也可能會以 <code>source</code> 為 <code>silent</code> 觸發，在這樣的情況下就不會觸發 <code>selection-change</code>。如果 <code>selection-change</code> 是 side effect 的話就很有用。例如：輸入文字造成 selection 變更，但每個字元都觸發 <code>selection-change</code> 的話就可能會造成干擾。</p><p>Callback Signature：</p><pre><code class="typescript">handler(range: &#123; index: Number, length: Number &#125;,        oldRange: &#123; index: Number, length: Number &#125;,        source: String)</code></pre><p>範例：</p><pre><code class="typescript">quill.on(&#39;selection-change&#39;, function(range, oldRange, source) &#123;  if (range) &#123;     if (range.length == 0) &#123;      console.log(&#39;User cursor is on&#39;, range.index);    &#125; else &#123;       const text = quill.getText(range.index, range.length);      console.log(&#39;User has highlighted&#39;, text);    &#125;   &#125; else &#123;     console.log(&#39;Cursor not in the editor&#39;);   &#125;&#125;);</code></pre><h3 id="editor-change"><a href="#editor-change" class="headerlink" title="editor-change"></a>editor-change</h3><p>當觸發 <code>text-change</code> 或 <code>selection-change</code> 事件時，也會跟著觸發 <code>editor-change</code>，即使 <code>source</code> 是 <code>silent</code> 也是一樣。第一個參數是事件名稱，不是 <code>text-change</code> 就是 <code>selection-change</code>，之後的通常是傳遞給這些相應的 handler 參數。</p><p>Callback Signature：</p><pre><code class="typescript">handler(name: String, ...args)</code></pre><p>範例：</p><pre><code class="typescript">quill.on(&#39;editor-change&#39;, function(eventName, ...args) &#123;  if (eventName === &#39;text-change&#39;) &#123;     // args[0] will be delta   &#125; else if (eventName === &#39;selection-change&#39;) &#123;    // args[0] will be old range   &#125;&#125;);</code></pre><h2 id="on"><a href="#on" class="headerlink" title="on"></a>on</h2><p>監聽特定的事件並加入 event handler。</p><p>方法：</p><pre><code class="typescript">on(name: String, handler: Function): Quill</code></pre><p>範例：</p><pre><code class="typescript">quill.on(&#39;text-change&#39;, function() &#123;  console.log(&#39;Text change!&#39;); &#125;);</code></pre><h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><p>為事件的一次觸發加入 event handler。</p><p>方法：</p><pre><code class="typescript">once(name: String, handler: Function): Quill</code></pre><p>範例：</p><pre><code class="typescript">quill.once(&#39;text-change&#39;, function() &#123;  console.log(&#39;First text change!&#39;);&#125;);</code></pre><h2 id="off"><a href="#off" class="headerlink" title="off"></a>off</h2><p>移除 event handler</p><p>方法：</p><pre><code class="typescript">off(name: String, handler: Function): Quill</code></pre><p>範例：</p><pre><code class="typescript">function handler() &#123;   console.log(&#39;Hello!&#39;);&#125;quill.on(&#39;text-change&#39;, handler);quill.off(&#39;text-change&#39;, handler);</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>Quill 提供了三種事件監聽類型分別是 <code>text-change</code>，<code>selection-change</code>，以及 <code>editor-change</code>，整理一下今天練習的 event 方法：</p><ul><li><strong>text-change</strong>：內容變化時觸發，包括使用者操作或API呼叫等。</li><li><strong>selection-change</strong>：選取範圍變更時觸發，提供選取的邊界，也能作為焦點變更的事件。</li><li><strong>editor-change</strong>：結合觸發 <code>text-change</code> 與 <code>selection-change</code> 的變更。</li><li><strong>on</strong>：根據監聽類型加入對應的事件處理器。</li><li><strong>once</strong>：根據監聽類型加入只執行一次的事件處理器。</li><li><strong>off</strong>：移除事件處理器。</li></ul><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>前幾天在 DefinitelyTyped 提的 Quill PR 終於合併了，目前只要重新 npm install 就能夠把 OP 類型錯誤的問題解決了，要確認一下 types 的版本是 <code>2.0.12</code>。久違的 OpenSource contribution XD 希望對大家有所幫助 :D</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/789afdecfc34b102d486f85722dca578eecf4bfc">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#events">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10332125">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天來看 Events 的部分，Event 的使用方式就和 JavaScript 的事件監聽一樣，透過指定的事件名稱來監聽，並執行指定的方法。&lt;/p&gt;
&lt;h3 id=&quot;text-change&quot;&gt;&lt;a href=&quot;#text-change&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 15：讀 Quill Editor API 技術文件 - Editor</title>
    <link href="https://blog.crazyalu.com/2023/09/30/quill-day-15/"/>
    <id>https://blog.crazyalu.com/2023/09/30/quill-day-15/</id>
    <published>2023-09-30T12:37:25.000Z</published>
    <updated>2024-02-21T14:30:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>今天繼續配著烤肉和月餅來看 Editor 的部分。Editor API 比前面的操作簡單一些，主要用在判斷使用者的游標或焦點狀態，並提供啟用與禁用編輯功能。</p><h2 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h2><p>移除編輯器的 <code>focus</code> 狀態，從使用這的角度來看就是輸入文字的游標離開編輯器。</p><p>方法：</p><pre><code class="typescript">blur()</code></pre><p>範例：</p><pre><code class="typescript">quill.blur();</code></pre><h2 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h2><p>控制編輯器是否能讓使用者進行輸入。當編輯器在 <code>disabled</code> 狀態時，不影響 <code>source</code> 為 <code>api</code> 與 <code>slient</code> 的 API 呼叫。</p><p>方法：</p><pre><code class="typescript">enable(enabled: boolean = true)</code></pre><p>範例：</p><pre><code class="typescript">quill.enable();quill.enable(false); // 禁用使用者輸入</code></pre><h2 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h2><p>將編輯器設為禁用編輯狀態，如同上面的範例所提到的，相當於 <code>enable(false)</code> 的意思。</p><h2 id="focus"><a href="#focus" class="headerlink" title="focus"></a>focus</h2><p>將焦點回到編輯器上，游標會停留在上一次離開 (<code>blur</code>) 的地方。</p><p>方法：</p><pre><code class="typescript">focus()</code></pre><p>範例：</p><pre><code class="typescript">quill.focus();</code></pre><h2 id="hasFocus"><a href="#hasFocus" class="headerlink" title="hasFocus"></a>hasFocus</h2><p>確認焦點是否在編輯器的輸入範圍，這邊需要留意的是焦點在 <code>toolbar</code> 或是 <code>tooltip</code> 時，都不算在編輯器。</p><p>方法：</p><pre><code class="typescript">hasFocus(): Boolean</code></pre><p>範例：</p><pre><code class="typescript">quill.hasFocus();</code></pre><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>同步檢查編輯器的使用者更新，並在發生修改時觸發事件。對於有協作需求要解決衝突時，需要最新的狀態下相當實用。<code>Source</code> 的來源可以是 <code>user</code>，<code>api</code>， 以及 <code>silent</code>。</p><p>由於這主要是用於線上共筆時可能造成編輯衝突時，可以透過 <code>update</code> 方法來同步編輯器的狀態，因此這之後如果有機會再來嘗試看看。</p><p>方法：</p><pre><code class="typescript">update(source: String = &#39;user&#39;)</code></pre><p>範例：</p><pre><code class="typescript">quill.update();</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>稍微回顧一下今天研究 Editor 相關的 API：</p><ul><li><strong>blur</strong>：移除編輯器的焦點狀態。</li><li><strong>enable</strong>：控制編輯器是否能讓使用者進行輸入，包括禁用使用者輸入。</li><li><strong>disable</strong>：相當於 <code>enable(false)</code>，禁止使用者輸入。</li><li><strong>focus</strong>：將焦點回到編輯器上，游標停留在上次離開的地方。</li><li><strong>hasFocus</strong>：確認焦點是否在編輯器上。</li><li><strong>update</strong>：同步檢查編輯器的使用者更新並在修改時觸發事件。<br>除了 <code>update</code> 的操作沒辦法立即呈現之外，大部分的 API 都還滿淺顯易懂的。</li></ul><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>今天邊塞車邊寫文章，還好有弟弟幫忙開車，早上七點多有驚無險的避免了一場危險，前面的車子似乎快睡著了又沒有打開車道維持輔助，導致車子直接嚕到中央護欄，還好沒翻車，雖然沒看到左側的鈑金狀況，但應該是滿慘的。再次證明了保持車距的重要性。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/6f5bc5d83ebb73e78952a4567ea22f006343dd64">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#editor">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10331555">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天繼續配著烤肉和月餅來看 Editor 的部分。Editor API 比前面的操作簡單一些，主要用在判斷使用者的游標或焦點狀態，並提供啟用與禁用編輯功能。&lt;/p&gt;
&lt;h2 id=&quot;blur&quot;&gt;&lt;a href=&quot;#blur&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 14：讀 Quill Editor API 技術文件 - Selection</title>
    <link href="https://blog.crazyalu.com/2023/09/29/quill-day-14/"/>
    <id>https://blog.crazyalu.com/2023/09/29/quill-day-14/</id>
    <published>2023-09-29T06:03:01.000Z</published>
    <updated>2024-02-21T14:30:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>昨天研究並練習關於套用文本的行內與區塊樣式，初步把每個 API 的使用方式都看過一遍，今天輪到編輯器選取功能相關的 API，繼續給他看下去 XD</p><h2 id="getBounds"><a href="#getBounds" class="headerlink" title="getBounds"></a>getBounds</h2><p>這個方法非常實用，用於獲取指定索引或選取範圍的界限（bounds）。並返回一個包含界限的物件，裡面會有 <code>left</code>，<code>top</code>，<code>width</code> 以及 <code>height</code> 屬性，分別代表指定索引的左上角位置和尺寸。通常用來定位游標或選取的範圍在編輯器容器內的位置。例如可以利用這個方法決定在編輯器內容旁邊或是游標的位置顯示自訂的選單或者工具提示。</p><p>方法：</p><pre><code class="typescript">getBounds(index: Number, length: Number = 0):     &#123; left: Number, top: Number, height: Number, width: Number &#125;</code></pre><p>範例：<br>先在編輯器的元素下面新增一個 <code>tooltip</code> 標籤：</p><pre><code class="html">&lt;div id=&quot;tooltip&quot; style=&quot;display: none; position: absolute; background-color: lightgray;&quot;&gt; 我是一個小提示 &lt;/div&gt;</code></pre><p>實現監聽事件，在文本選取的時候判斷選取的位置來顯示 tooltip：</p><pre><code class="typescript">// 監聽文本選擇事件quill.on(&#39;selection-change&#39;, function(range) &#123;  if (range) &#123;    if (range.length &gt; 0) &#123;      // 獲取選擇範圍的界限      const bounds = quill.getBounds(range.index, range.length);      // 定位和顯示小提示      const tooltip = document.getElementById(&#39;tooltip&#39;);      tooltip.style.left = bounds.left + &#39;px&#39;;      tooltip.style.top = (bounds.top + bounds.height) + &#39;px&#39;;      tooltip.style.display = &#39;block&#39;;    &#125; else &#123;      // 隱藏小提示      const tooltip = document.getElementById(&#39;tooltip&#39;);      tooltip.style.display = &#39;none&#39;;    &#125;  &#125;&#125;);</code></pre><p>效果如下：<br><img src="/2023/09/29/quill-day-14/20090749cNFuDeHiXF.png" alt="Tooltip 效果如下"></p><h2 id="getSelection"><a href="#getSelection" class="headerlink" title="getSelection"></a>getSelection</h2><p>獲取編輯器中當前的選取範圍。可帶入 optional 參數 <code>focus</code>，如果為 <code>true</code>，則獲取焦點之後返回選取的範圍 <code>index</code> 與 <code>length</code>，如果為 <code>false</code>，則返回 <code>null</code>。</p><p>方法：</p><pre><code class="typescript">getSelection(focus = false): &#123; index: Number, length: Number &#125;</code></pre><p>範例：</p><pre><code class="typescript">var range = quill.getSelection();if (range) &#123;  if (range.length == 0) &#123;    console.log(&#39;User cursor is at index&#39;, range.index);  &#125; else &#123;    var text = quill.getText(range.index, range.length);    console.log(&#39;User has highlighted: &#39;, text);  &#125;&#125; else &#123;  console.log(&#39;User cursor is not in editor&#39;);&#125;  </code></pre><h2 id="setSelection"><a href="#setSelection" class="headerlink" title="setSelection"></a>setSelection</h2><p>設置編輯器中的選取範圍，這也會使編輯器是在 <code>focus</code> 的狀態。如果傳入的參數為 <code>null</code>，則會離開焦點並觸發 <code>blur</code> 事件。</p><p>方法：</p><pre><code class="typescript">setSelection(index: Number, length: Number = 0, source: String = &#39;api&#39;)setSelection(range: &#123; index: Number, length: Number &#125;, source: String = &#39;api&#39;)</code></pre><p>範例：</p><pre><code class="typescript">quill.setSelection(0, 5);</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>稍微整理一下：</p><ul><li><code>getBounds</code>: 獲取指定索引的座標或界限資訊，常用於定位游標或選取範圍在編輯器內的位置。</li><li><code>getSelection</code>: 獲取編輯器中當前的選取範圍，可用於判斷用戶選取的內容或游標位置。</li><li><code>setSelection</code>: 設置編輯器中的選取範圍，使編輯器處於 Focus 狀態。</li></ul><p>今天詳細探討了編輯器的 Selection 功能，Quill 提供了選取範圍相關的控制方法，到目前為止，無論是文本樣式或是內容選取，可以看到大部分的操作都離不開 <code>index</code> 與 <code>length</code>，而 <code>range</code> 是一個滿方便使用的參數，可以知道選取的起點以及選取的長度，以便我們在自訂功能的時候可以做為位置索引的參考。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>已經好幾年沒有玩過手機遊戲了，最近上下班通勤時間都會玩一款新的手機遊戲叫 Monster Hunter Now，整體還滿有趣的，是 Niantic 也就是開發 Ingress 以及 Pokemon Go 的開發商，這遊戲也是要走出去戶外實際去看地圖上有哪些資源以及魔物，也能夠與其他玩家來進行遊戲。不過有個小缺點，就是當 HP 不夠的時候需要使用藥水，那個藥水除了每天提供五罐免費的之外，其他時間若喝完的話，就需要等時間回復或者直接打開線上商城買藥水道具，就是要課金的意思，但畢竟是休閒，沒血的話就乖乖的等待回滿再繼續被魔物虐了 XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/5a1302ac5145a19ebd6df9db2f9d6f22c4a66141">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#selection">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10330722">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天研究並練習關於套用文本的行內與區塊樣式，初步把每個 API 的使用方式都看過一遍，今天輪到編輯器選取功能相關的 API，繼續給他看下去 XD&lt;/p&gt;
&lt;h2 id=&quot;getBounds&quot;&gt;&lt;a href=&quot;#getBounds&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 13：讀 Quill Editor API 技術文件 - Formatting</title>
    <link href="https://blog.crazyalu.com/2023/09/28/quill-day-13/"/>
    <id>https://blog.crazyalu.com/2023/09/28/quill-day-13/</id>
    <published>2023-09-28T15:36:23.000Z</published>
    <updated>2024-02-21T14:30:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>繼昨天的 Contents 相關的 API，今天來看看 Formatting 的部分。</p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>根據使用者當前選擇的字串套用文字格式，回傳的 Delta 代表變更的內容。當使用者選擇字串長度為 <code>0</code> 時，代表是游標的狀態，對應的文字樣式則會變成啟動狀態，使用者接下來輸入的內容則會套用啟動的文字樣式。<code>Source</code> 一樣可以設定 <code>user</code>，<code>api</code> 或 <code>silent</code>。當呼叫的時候如果編輯器為禁用(disabled) 狀態，則會直接略過 <code>source</code> 為 <code>user</code> 的呼叫。</p><ul><li><code>source</code> 預設是 <code>api</code></li></ul><p>方法：</p><pre><code class="typescript">format(name: String, value: any, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.format(&#39;color&#39;, &#39;red&#39;);quill.format(&#39;align&#39;, &#39;right&#39;);</code></pre><h2 id="formatLine"><a href="#formatLine" class="headerlink" title="formatLine"></a>formatLine</h2><p>將選到的行數套用樣式，回傳的 Delta 代表變更的內容。關於可使用的樣式有哪些，可以參考官網文件 <a href="https://quilljs.com/docs/formats/">formats</a>描述。這個方法主要是處理區塊 (block) 樣式，當呼叫的時候如果帶入的樣式是屬於行內 (inline) 樣式，則會沒有效果。要移除格式的話直接在 <code>value</code> 的參數傳入 <code>false</code> 即可。另外套用區塊樣式的時候，可能會在套用後導致使用者當前的選擇被取消，並且游標移動到新的位置。</p><ul><li><code>source</code> 預設是 <code>api</code></li></ul><p>方法：</p><pre><code class="typescript">formatLine(index: Number, length: Number, source: String = &#39;api&#39;): DeltaformatLine(index: Number, length: Number, format: String, value: any, source: String = &#39;api&#39;): Delta formatLine(index: Number, length: Number, formats: &#123; [String]: any &#125;, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello\nWorld!\n&#39;);quill.formatLine(1, 2); // 沒有給樣式的話，預設套用的樣式是 boldquill.formatLine(1, 2, &#39;align&#39;, &#39;right&#39;); // 第一行置右quill.formatLine(4, 4, &#39;align&#39;, &#39;center&#39;); // 兩行都置中// 套用多個區塊樣式quill.formatLine(0, 5, &#123;  list: &#39;bullet&#39;,  align: &#39;right&#39;,&#125;);</code></pre><h2 id="format-VS-formatLine"><a href="#format-VS-formatLine" class="headerlink" title="format VS formatLine"></a>format VS formatLine</h2><p>最主要的差別就是 <code>format</code> 用在更改選取範圍內的特定格式，例如字體大小、顏色、粗體等。而 <code>formatLine</code> 處理的是整行的樣式，例如列表、對齊方式等。</p><h2 id="formatText"><a href="#formatText" class="headerlink" title="formatText"></a>formatText</h2><p>一樣是在編輯器針對選定的範圍套用文字的樣式，回傳的是內容變更的 Delta，如果要移除文字樣式，則直接在對應樣式的值帶入 <code>false</code> 即可移除。如果是操作 block 相關的樣式，使用者的選擇範圍可能不會保留。<code>Source</code> 的來源有 <code>user</code>，<code>api</code>，以及 <code>silent</code>，當編輯器為 <code>disabled</code> 狀態則會直接無視 <code>source</code> 為 <code>user</code> 的呼叫。</p><ul><li><code>source</code> 預設是 <code>api</code></li></ul><p>方法：</p><pre><code class="typescript">formatText(index: Number, length: Number, source: String = &#39;api&#39;): Delta formatText(index: Number, length: Number, format: String, value: any, source: String = &#39;api&#39;): DeltaformatText(index: Number, length: Number, formats: &#123; [String]: any &#125;, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello\nWorld!\n&#39;);quill.formatText(0, 5, &#39;bold&#39;, true); // 將 Hello 設為粗體quill.formatText(0, 5, &#123; // 將 Hello 解除粗體，並設為藍色   &#39;bold&#39;: false,   &#39;color&#39;: &#39;rgb(0, 0, 255)&#39;  &#125;);quill.formatText(5, 1, &#39;align&#39;, &#39;right&#39;); // 將 Hello 的那一行置右</code></pre><h2 id="getFormat"><a href="#getFormat" class="headerlink" title="getFormat"></a>getFormat</h2><p>這個方法可以讓我們查詢特定範圍內文字的格式。如果範圍內的所有文字共用相同的格式，則會回傳該格式。如果有不同的真值 (truthy value)，則會回傳所有的真值在陣列中。當不帶參數呼叫此方法，將針對當前使用者選取的範圍進行操作。</p><ul><li><code>source</code> 預設是 <code>api</code></li></ul><p>方法：</p><pre><code class="typescript">getFormat(range: Range = current): &#123; [String]: any &#125;getFormat(index: Number, length: Number = 0): &#123; [String]: any &#125;</code></pre><p>範例：</p><pre><code class="typescript">// 假設設定一段文字 Hello World!，並設定樣式quill.setText(&#39;Hello World!&#39;);quill.formatText(0, 2, &#39;bold&#39;, true);quill.formatText(1, 2, &#39;italic&#39;, true);quill.getFormat(0, 2); // &#123; bold: true &#125;quill.getFormat(1, 1); // &#123; bold: true, italic: true &#125;quill.formatText(0, 2, &#39;color&#39;, &#39;red&#39;);quill.formatText(2, 1, &#39;color&#39;, &#39;blue&#39;);quill.getFormat(0, 3); // &#123; color: [&#39;red&#39;, &#39;blue&#39;] &#125;quill.setSelection(3);quill.getFormat(); // &#123; italic: true, color: &#39;blue&#39; &#125;quill.format(&#39;strike&#39;, true);quill.getFormat(); // &#123; italic: true, color: &#39;blue&#39;, strike: true &#125;quill.formatLine(0, 1, &#39;align&#39;, &#39;right&#39;);quill.getFormat(); // &#123; italic: true, color: &#39;blue&#39;, strike: true, // align: &#39;right&#39; &#125;</code></pre><h2 id="removeFormat"><a href="#removeFormat" class="headerlink" title="removeFormat"></a>removeFormat</h2><p>將選定的範圍內刪除所有的格式及嵌入內容，並回復到沒有格式的狀態。回傳的 Delta 代表變更的操作，如果範圍內包含到 block format，也會一併移除。因此使用者的選取狀態可能不會被保留。<code>Source</code> 可以是 <code>user</code>，<code>api</code> 或 <code>silent</code>。當編輯器為 <code>disabled</code> 狀態時，<code>source</code> 為 <code>user</code> 的呼叫將會被忽略。</p><ul><li><code>source</code> 預設是 <code>api</code></li></ul><p>方法：</p><pre><code class="typescript">removeFormat(index: Number, length: Number, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.setContents([  &#123; insert: &#39;Hello&#39;, &#123; bold: true &#125; &#125;,  &#123; insert: &#39;\n&#39;, &#123; align: &#39;center&#39; &#125; &#125;,  &#123; insert: &#123; formula: &#39;x^2&#39; &#125; &#125;,  &#123; insert: &#39;\n&#39;, &#123; align: &#39;center&#39; &#125; &#125;,  &#123; insert: &#39;World&#39;, &#123; italic: true &#125;&#125;,  &#123; insert: &#39;\n&#39;, &#123; align: &#39;center&#39; &#125; &#125;]);quill.removeFormat(3, 7);// 編輯器在執行之後內容會變成// [// &#123; insert: &#39;Hel&#39;, &#123; bold: true &#125; &#125;,// &#123; insert: &#39;lo\n\nWo&#39; &#125;,// &#123; insert: &#39;rld&#39;, &#123; italic: true &#125;&#125;,// &#123; insert: &#39;\n&#39;, &#123; align: &#39;center&#39; &#125; &#125;// ]</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天嘗試使用格式化相關的 API，基本上使用的方式都差不多，但我們還沒討論到 Format 還有哪些可以使用，剛才的介紹中也有提到<a href="https://quilljs.com/docs/formats/">這篇文件</a>有列出所有支援的格式，要找時間來實驗看看並感受一下。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>明天就開始一小段假期，不過按照往年的慣例，都會先回去宜蘭開車回台南拜拜，希望這次塞車不要塞的太久QQ，儘管早上四點半就起床，五點就出門了，到了七八點還是會開始塞。印象中過台中之前都滿大的機會遇到塞車的情況，還好可以跟弟弟輪流開，不至於累到不行 XD </p><p>祝中秋佳節愉快 :)</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/275e5d30a3206460dfbca1cc292dda0f6d5f15f5">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#format">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10330316">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;繼昨天的 Contents 相關的 API，今天來看看 Formatting 的部分。&lt;/p&gt;
&lt;h2 id=&quot;format&quot;&gt;&lt;a href=&quot;#format&quot; class=&quot;headerlink&quot; title=&quot;format&quot;&gt;&lt;/a&gt;format&lt;/h2&gt;&lt;p&gt;根據使</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 12：讀 Quill Editor API 技術文件 - Content (下)</title>
    <link href="https://blog.crazyalu.com/2023/09/27/quill-day-12/"/>
    <id>https://blog.crazyalu.com/2023/09/27/quill-day-12/</id>
    <published>2023-09-27T13:53:21.000Z</published>
    <updated>2024-02-21T14:30:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>今天就繼續來看 Content 相關的 API 後半段。</p><h2 id="insertEmbed"><a href="#insertEmbed" class="headerlink" title="insertEmbed"></a>insertEmbed</h2><p>將嵌入式內容插入編輯器，return 為更改後的 Delta 物件。<code>source</code> 可以是 <code>user</code>、<code>api</code> 或 <code>silent</code>。當編輯器是 <code>disabled</code> 狀態時，當 <code>source</code> 設為 <code>user</code> 的呼叫則會被忽略。</p><ul><li><code>index</code> 可以選擇要插入的位置索引值</li></ul><p>方法：</p><pre><code class="typescript">insertEmbed(index: Number, type: String, value: any, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.insertEmbed(10, &#39;image&#39;, &#39;https://quilljs.com/images/cloud.png&#39;);</code></pre><h2 id="insertText"><a href="#insertText" class="headerlink" title="insertText"></a>insertText</h2><p>顧名思義將文字插入編輯器，可以選擇使用指定格式或多種格式。return 收到的是更新後的 Delta 物件。<code>source</code> 可以是 <code>user</code>、<code>api</code> 或 <code>silent</code>。當編輯器 <code>disabled</code> 時，<code>source</code> 為 <code>user</code> 的呼叫將直接略過。</p><p>方法共有三種，後兩者的差別在於 format 可以設一個或多個文字格式。</p><pre><code class="typescript">insertText(index: Number, text: String, source: String = &#39;api&#39;): Delta insertText(index: Number, text: String, format: String, value: any, source: String = &#39;api&#39;): Delta insertText(index: Number, text: String, formats: &#123; [String]: any &#125;, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.insertText(0, &#39;Hello&#39;); quill.insertText(3, &#39;Hello&#39;, &#39;bold&#39;, true); quill.insertText(8, &#39;Quill&#39;, &#123; &#39;color&#39;: &#39;#ffff00&#39;, &#39;italic&#39;: true &#125;);</code></pre><h2 id="setContents"><a href="#setContents" class="headerlink" title="setContents"></a>setContents</h2><p>將參數的內容覆蓋編輯器。內容必須以換行符號 <code>\n</code> 結尾。return 收到的是更新後的 Delta。如果給定 Delta 沒有無效操作，這將與傳入的 Delta 相同。<code>source</code> 可以為 <code>user</code>、<code>api</code> 或 <code>silent</code>。當編輯器是 <code>disabled</code> 狀態時，當<code>source</code> 為 <code>user</code> 的呼叫則會被忽略。</p><p>方法：</p><pre><code class="typescript">setContents(delta: Delta, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">// 使用 new Delta() 新增 Delta 物件const delta = new Delta()    .insert(&#39;This is a title&#39;)    .insert(&#39;\n&#39;, &#123; header: 1 &#125;)    .insert(&#39;This is a subtitle \n&#39;, &#123;header: 2, color: &#39;red&#39; &#125;)    .insert(&#39;The description is Hello World&#39;, &#123;    bold: true,    color: &#39;purple&#39;,    &#125;);quill.setContents(delta);</code></pre><p>上面這個範例可以觀察到套用 <code>header</code> 的變化，除了從 <code>text-change</code> 觀察到的套用方式，如果想要在一個 <code>insert</code> 就實現樣式與 <code>header</code> 格式套用，可以在文字內容的最後加上換行符號，這樣加上 <code>header</code> 在 <code>attribute</code> 上才會有效果。</p><h2 id="setText"><a href="#setText" class="headerlink" title="setText"></a>setText</h2><p>將純文字內容覆蓋到編輯器，return 收到的是更新後的 Delta，文字內容必須以換行符號做結尾，沒有加上的話，編輯器會另外加上。與 <code>setContents</code> 不同的是，<code>setText</code> 只能將純文字覆蓋到編輯器，而 <code>setContents</code> 的文字內容可以包含不同的格式。<code>source</code> 可以為 <code>user</code>、<code>api</code> 或 <code>silent</code>，預設是 <code>api</code>。當編輯器是 <code>disabled</code> 狀態時，當<code>source</code> 為 <code>user</code> 的呼叫則會被忽略。</p><p>方法：</p><pre><code class="typescript">setText(text: String, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.setText(&#39;Hello\n&#39;);</code></pre><h2 id="updateContents"><a href="#updateContents" class="headerlink" title="updateContents"></a>updateContents</h2><p>將 Delta 資料更新到編輯器，return 收到的是更新操作的 Delta。如果傳入的 Delta 沒有不合法的操作，return 收到的 Delta 則會是相同的內容。舉例來說，當編輯器沒有內容，但仍然執行 <code>retain(6)</code> 的話，實際上回傳的 Delta 中的 <code>retain</code> 會只有 1，因為空白的編輯器會預設一個換行符號，因此長度只有 <code>1</code> 可以 <code>retain</code>。<br>另外，即使執行 <code>delete(5)</code>，收到的 Delta 變化也不會有看到 ops 中有 <code>delete</code> 的操作，畢竟編輯器沒有內容可以讓我們刪除。</p><p>方法：</p><pre><code class="typescript">updateContents(delta: Delta, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">// 假設編輯器當前的內容 [&#123; insert: &#39;Hello World!&#39; &#125;]quill.updateContents(new Delta()  .retain(6) // Keep &#39;Hello &#39;  .delete(5) // &#39;World&#39; is deleted  .insert(&#39;Quill&#39;)  .retain(1, &#123; bold: true &#125;) // Apply bold to exclamation mark);// 編輯器現在會變成 [//   &#123; insert: &#39;Hello Quill&#39; &#125;,//   &#123; insert: &#39;!&#39;, attributes: &#123; bold: true&#125; &#125;// ]</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>在實際看過每個方法及體驗過使用方式後，對於 Contents API 的運用有初步的認識，並在不同的情境下選擇適合的 API ，透過帶入不同參數的呼叫方式實現功能，我們也可以在特殊情況自訂 <code>source</code> 來決定保留或跳過編輯器的觸發機制，明天接著進入到 Formatting 的章節，也就是套用文字格式。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>最近午餐跟著其他同事點外賣，不過也許是上班日的關係，在尖峰時段單點東西似乎特別容易漏掉，漏餐的話，幫忙開團的同事還要確認是否有其他同事也沒拿到，然後還要處理退款的申請，再次感謝願意開團的同事 XD。看來以後在尖峰時段還是盡量點套餐比較保險…也許吧XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/ee5d69d6180cba551f71523af00152bf827b6f01">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#content">Quill API - Conetent</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10329481">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天就繼續來看 Content 相關的 API 後半段。&lt;/p&gt;
&lt;h2 id=&quot;insertEmbed&quot;&gt;&lt;a href=&quot;#insertEmbed&quot; class=&quot;headerlink&quot; title=&quot;insertEmbed&quot;&gt;&lt;/a&gt;insertEmbed&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
  <entry>
    <title>Day 11：讀 Quill Editor API 技術文件 - Content (上)</title>
    <link href="https://blog.crazyalu.com/2023/09/26/quill-day-11/"/>
    <id>https://blog.crazyalu.com/2023/09/26/quill-day-11/</id>
    <published>2023-09-26T13:54:11.000Z</published>
    <updated>2024-02-21T14:30:19.994Z</updated>
    
    <content type="html"><![CDATA[<p>今天開始來細看 Quill Editor 的技術文件，看看 Quill 有哪些方法可以使用。同時也準備了範例練習，實際呼叫並觀察也許會比較有感覺。這會是一段細節探索的旅程。</p><h2 id="關於-Source"><a href="#關於-Source" class="headerlink" title="關於 Source"></a>關於 <code>Source</code></h2><p>在閱讀技術文件的時候，有部分的 <code>function</code> 會提供 <code>Source</code> 的參數名稱，稍微研究了一下。</p><ul><li>API：當更改的事件來自 API 的呼叫，例如直接用 JavaScript 呼叫 Instance 的 function</li><li>User：當變更來自使用者的操作時，例如：使用者在編輯器打字輸入內容、貼上圖片或是修改文字樣式。</li><li>Silent：此選項允許我們在不觸發任何 Quill 事件的情況下進行更改。這在某些情況下很實用，例如，我們想要在不通知其他程式的情況下更新編輯器的內容。</li></ul><p>大部分的情況是不需要自訂設定這些值，只有在較特殊的情況下，需要額外設置以更精確的控制編輯的行為。例如：</p><pre><code class="typescript">// 使用 &#39;api&#39; 作為 source，代表這個更改是由 API 控制的quill.format(&#39;bold&#39;, true, &#39;api&#39;); // 使用 &#39;user&#39; 作為 source，代表這個更改是模擬使用者操作quill.format(&#39;italic&#39;, true, &#39;user&#39;); </code></pre><p>透過這樣的分別使用，我們可以在事件監聽或其他處理邏輯中區分更改的來源，進而執行不同的操作或處理。例如我們只對使用者所做的更改進行特定的處理，並忽略由 API 控制的更改。透過 <code>source</code> 的設置就讓我們滿足這樣的需求。</p><h2 id="deleteText：在指定位置刪除文字"><a href="#deleteText：在指定位置刪除文字" class="headerlink" title="deleteText：在指定位置刪除文字"></a>deleteText：在指定位置刪除文字</h2><p>刪除的來源可以是從 <code>user</code>, <code>api</code> 或 <code>silent</code>。當編輯器狀態為 disabled 時，會直接忽略掉從 <code>user</code> 來的呼叫</p><p>方法：</p><pre><code class="typescript">deleteText(index: Number, length: Number, source: String = &#39;api&#39;): Delta</code></pre><p>範例：</p><pre><code class="typescript">quill.deleteText(4, 6) // 從第 4 個位置，刪除長度 6 的內容</code></pre><h2 id="getContents：獲取編輯器指定位置與長度的內容"><a href="#getContents：獲取編輯器指定位置與長度的內容" class="headerlink" title="getContents：獲取編輯器指定位置與長度的內容"></a>getContents：獲取編輯器指定位置與長度的內容</h2><p>獲取編輯器的內容以及格式資料，收到的是 Delta 物件。可選參數有兩個：</p><ul><li><code>index</code>：指定獲取內容的起始索引，預設是從 <code>0</code></li><li><code>length</code>：指定要獲取內容的長度，預設 <code>remaining</code> 是指從起始索引後的剩餘內容</li></ul><p>方法：</p><pre><code class="typescript">getContents(index: Number = 0, length: Number = remaining): Delta</code></pre><p>範例：</p><pre><code class="typescript">// 獲取完整內容的 Deltaconst delta = quill.getContents();// 獲取部分內容的 Deltaconst delta = quill.getContents(27, 5);</code></pre><h2 id="getLength：獲取編輯器內容的長度"><a href="#getLength：獲取編輯器內容的長度" class="headerlink" title="getLength：獲取編輯器內容的長度"></a>getLength：獲取編輯器內容的長度</h2><p>獲取編輯器內容的長度。<strong>需要注意的是，即使 Quill 為空，仍然有一個由 ‘\n’ 表示的空行，因此 getLength 將返回 1</strong>。</p><p>方法：</p><pre><code class="typescript">getLength(): Number</code></pre><p>範例：</p><pre><code class="typescript">const length = quill.getLength();</code></pre><h2 id="getText：獲取指定位置與長度的文本內容"><a href="#getText：獲取指定位置與長度的文本內容" class="headerlink" title="getText：獲取指定位置與長度的文本內容"></a>getText：獲取指定位置與長度的文本內容</h2><p>獲取編輯器的字串內容，非字串的內容會直接省略，因此返回的字串長度可能會比呼叫 <code>getLength</code> 回傳的編輯器長度短些。這邊一樣要留意的是，即使編輯器是空的沒有內容，仍然會留一個空行，所以在這樣的情況將會返回 <code>\n</code>。</p><ul><li><code>index</code>：指定獲取內容的起始索引，預設是從 <code>0</code></li><li><code>length</code>：指定要獲取內容的長度，預設 <code>remaining</code> 是指從起始索引後的剩餘內容</li></ul><p>方法：</p><pre><code class="typescript">getText(index: Number = 0, length: Number = remaining): String</code></pre><p>範例：</p><pre><code class="typescript">// 獲取從 0 開始，長度為 10 的文本內容const text = quill.getText(0, 10);</code></pre><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>今天開始仔細閱讀技術文件，會相對的比較乏味，但是能徹底的去看每個方法及參數要如何使用，知道自己有哪些武器可以用，對於特殊的需求也比較能找到合適的方法來實現。</p><h4 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h4><p>由於中秋節快到了，開始收到各種月餅禮盒，周遭也開始出現柚子，雖然還沒開始烤肉，但希望中秋之後別長太多肥肉出來，剛轉換跑道一陣子，還在適應節奏的階段，需要找到合適的運動時間，目前看來只剩下早上了，下班後加上通勤時間到健身房，運動完回家洗完澡也差不多到睡覺的時間了，最近嘗試調整起床的時間，先從六點半開始觀察看看囉…XD</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://github.com/jeffwu85182/quill-editor-todo/commit/1f147960445f8f26c42cc653221d10e7443cabdc">今日份的練習</a></li><li><a href="https://quilljs.com/docs/api/#content">API - Quill Rich Text Editor (quilljs.com)</a></li></ul><p>文章同步發表於<a href="https://ithelp.ithome.com.tw/articles/10328811">2023 iThome 鐵人賽</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天開始來細看 Quill Editor 的技術文件，看看 Quill 有哪些方法可以使用。同時也準備了範例練習，實際呼叫並觀察也許會比較有感覺。這會是一段細節探索的旅程。&lt;/p&gt;
&lt;h2 id=&quot;關於-Source&quot;&gt;&lt;a href=&quot;#關於-Source&quot; class=</summary>
      
    
    
    
    <category term="Angular" scheme="https://blog.crazyalu.com/categories/Angular/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/categories/Angular/Quill/"/>
    
    
    <category term="15th 30 Days Challenge" scheme="https://blog.crazyalu.com/tags/15th-30-Days-Challenge/"/>
    
    <category term="Quill" scheme="https://blog.crazyalu.com/tags/Quill/"/>
    
  </entry>
  
</feed>
